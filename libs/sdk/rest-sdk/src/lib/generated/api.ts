/* tslint:disable */
/* eslint-disable */
/**
 * 
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface CompleteForgotPasswordArgs
 */
export interface CompleteForgotPasswordArgs {
    /**
     * 
     * @type {string}
     * @memberof CompleteForgotPasswordArgs
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof CompleteForgotPasswordArgs
     */
    'confirmPassword': string;
    /**
     * 
     * @type {string}
     * @memberof CompleteForgotPasswordArgs
     */
    'fingerprint': string;
    /**
     * 
     * @type {string}
     * @memberof CompleteForgotPasswordArgs
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface CompleteSignUpArgs
 */
export interface CompleteSignUpArgs {
    /**
     * 
     * @type {string}
     * @memberof CompleteSignUpArgs
     */
    'fingerprint': string;
    /**
     * 
     * @type {string}
     * @memberof CompleteSignUpArgs
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface CreateFullMetricsGithubMetricDto
 */
export interface CreateFullMetricsGithubMetricDto {
    /**
     * 
     * @type {string}
     * @memberof CreateFullMetricsGithubMetricDto
     */
    'metricName': string;
    /**
     * 
     * @type {number}
     * @memberof CreateFullMetricsGithubMetricDto
     */
    'metricValue': number;
    /**
     * 
     * @type {string}
     * @memberof CreateFullMetricsGithubMetricDto
     */
    'recordedAt': string;
    /**
     * 
     * @type {string}
     * @memberof CreateFullMetricsGithubMetricDto
     */
    'repositoryId': string;
}
/**
 * 
 * @export
 * @interface CreateFullMetricsGithubRepositoryStatisticsDto
 */
export interface CreateFullMetricsGithubRepositoryStatisticsDto {
    /**
     * 
     * @type {string}
     * @memberof CreateFullMetricsGithubRepositoryStatisticsDto
     */
    'periodType': string;
    /**
     * 
     * @type {number}
     * @memberof CreateFullMetricsGithubRepositoryStatisticsDto
     */
    'starsCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CreateFullMetricsGithubRepositoryStatisticsDto
     */
    'forksCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CreateFullMetricsGithubRepositoryStatisticsDto
     */
    'contributorsCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CreateFullMetricsGithubRepositoryStatisticsDto
     */
    'commitsCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CreateFullMetricsGithubRepositoryStatisticsDto
     */
    'lastCommitDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateFullMetricsGithubRepositoryStatisticsDto
     */
    'recordedAt': string;
    /**
     * 
     * @type {string}
     * @memberof CreateFullMetricsGithubRepositoryStatisticsDto
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateFullMetricsGithubRepositoryStatisticsDto
     */
    'repositoryId': string;
}
/**
 * 
 * @export
 * @interface CreateFullMetricsGithubTeamRepositoryDto
 */
export interface CreateFullMetricsGithubTeamRepositoryDto {
    /**
     * 
     * @type {string}
     * @memberof CreateFullMetricsGithubTeamRepositoryDto
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateFullMetricsGithubTeamRepositoryDto
     */
    'teamId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateFullMetricsGithubTeamRepositoryDto
     */
    'repositoryId': string;
}
/**
 * 
 * @export
 * @interface CreateFullMetricsGithubTeamUserDto
 */
export interface CreateFullMetricsGithubTeamUserDto {
    /**
     * 
     * @type {string}
     * @memberof CreateFullMetricsGithubTeamUserDto
     */
    'role'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateFullMetricsGithubTeamUserDto
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateFullMetricsGithubTeamUserDto
     */
    'teamId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateFullMetricsGithubTeamUserDto
     */
    'userId': string;
}
/**
 * 
 * @export
 * @interface CreateFullMetricsGithubUserRepositoryDto
 */
export interface CreateFullMetricsGithubUserRepositoryDto {
    /**
     * 
     * @type {string}
     * @memberof CreateFullMetricsGithubUserRepositoryDto
     */
    'role': string;
    /**
     * 
     * @type {string}
     * @memberof CreateFullMetricsGithubUserRepositoryDto
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateFullMetricsGithubUserRepositoryDto
     */
    'repositoryId': string;
}
/**
 * 
 * @export
 * @interface CreateFullMetricsGithubUserStatisticsDto
 */
export interface CreateFullMetricsGithubUserStatisticsDto {
    /**
     * 
     * @type {string}
     * @memberof CreateFullMetricsGithubUserStatisticsDto
     */
    'periodType': string;
    /**
     * 
     * @type {number}
     * @memberof CreateFullMetricsGithubUserStatisticsDto
     */
    'followersCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CreateFullMetricsGithubUserStatisticsDto
     */
    'followingCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CreateFullMetricsGithubUserStatisticsDto
     */
    'recordedAt': string;
    /**
     * 
     * @type {string}
     * @memberof CreateFullMetricsGithubUserStatisticsDto
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateFullMetricsGithubUserStatisticsDto
     */
    'userId': string;
}
/**
 * 
 * @export
 * @interface CreateFullMetricsUserDto
 */
export interface CreateFullMetricsUserDto {
    /**
     * 
     * @type {MetricsRole}
     * @memberof CreateFullMetricsUserDto
     */
    'userRole': MetricsRole;
    /**
     * 
     * @type {string}
     * @memberof CreateFullMetricsUserDto
     */
    'externalUserId': string;
}


/**
 * 
 * @export
 * @interface CreateMetricsGithubRepositoryDto
 */
export interface CreateMetricsGithubRepositoryDto {
    /**
     * 
     * @type {string}
     * @memberof CreateMetricsGithubRepositoryDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateMetricsGithubRepositoryDto
     */
    'owner': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateMetricsGithubRepositoryDto
     */
    'private': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateMetricsGithubRepositoryDto
     */
    'fork': boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateMetricsGithubRepositoryDto
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateMetricsGithubRepositoryDto
     */
    'url'?: string | null;
}
/**
 * 
 * @export
 * @interface CreateMetricsGithubTeamDto
 */
export interface CreateMetricsGithubTeamDto {
    /**
     * 
     * @type {string}
     * @memberof CreateMetricsGithubTeamDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateMetricsGithubTeamDto
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateMetricsGithubTeamDto
     */
    'tenantId': string;
}
/**
 * 
 * @export
 * @interface CreateMetricsGithubUserDto
 */
export interface CreateMetricsGithubUserDto {
    /**
     * 
     * @type {string}
     * @memberof CreateMetricsGithubUserDto
     */
    'login': string;
    /**
     * 
     * @type {string}
     * @memberof CreateMetricsGithubUserDto
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateMetricsGithubUserDto
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateMetricsGithubUserDto
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateMetricsGithubUserDto
     */
    'avatarUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateMetricsGithubUserDto
     */
    'websiteUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateMetricsGithubUserDto
     */
    'location'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateMetricsGithubUserDto
     */
    'telegramUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateMetricsGithubUserDto
     */
    'twitterUrl'?: string | null;
}
/**
 * 
 * @export
 * @interface CreateSsoTenantDto
 */
export interface CreateSsoTenantDto {
    /**
     * 
     * @type {string}
     * @memberof CreateSsoTenantDto
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof CreateSsoTenantDto
     */
    'name': string;
    /**
     * 
     * @type {object}
     * @memberof CreateSsoTenantDto
     */
    'nameLocale'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof CreateSsoTenantDto
     */
    'clientId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateSsoTenantDto
     */
    'clientSecret': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateSsoTenantDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateSsoTenantDto
     */
    'public': boolean;
}
/**
 * 
 * @export
 * @interface CreateWebhookDto
 */
export interface CreateWebhookDto {
    /**
     * 
     * @type {string}
     * @memberof CreateWebhookDto
     */
    'eventName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateWebhookDto
     */
    'endpoint': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateWebhookDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {object}
     * @memberof CreateWebhookDto
     */
    'headers'?: object | null;
    /**
     * 
     * @type {number}
     * @memberof CreateWebhookDto
     */
    'requestTimeout'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CreateWebhookDto
     */
    'workUntilDate'?: string | null;
}
/**
 * 
 * @export
 * @interface FilesError
 */
export interface FilesError {
    /**
     * Files error (FILES-000), Forbidden (FILES-001)
     * @type {string}
     * @memberof FilesError
     */
    'message': string;
    /**
     * 
     * @type {FilesErrorEnum}
     * @memberof FilesError
     */
    'code': FilesErrorEnum;
    /**
     * 
     * @type {object}
     * @memberof FilesError
     */
    'metadata'?: object;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const FilesErrorEnum = {
    Files000: 'FILES-000',
    Files001: 'FILES-001'
} as const;

export type FilesErrorEnum = typeof FilesErrorEnum[keyof typeof FilesErrorEnum];


/**
 * 
 * @export
 * @interface FilesPresignedUrls
 */
export interface FilesPresignedUrls {
    /**
     * 
     * @type {string}
     * @memberof FilesPresignedUrls
     */
    'downloadUrl': string;
    /**
     * 
     * @type {string}
     * @memberof FilesPresignedUrls
     */
    'uploadUrl': string;
}
/**
 * 
 * @export
 * @interface FindManyMetricsGithubMetricResponse
 */
export interface FindManyMetricsGithubMetricResponse {
    /**
     * 
     * @type {Array<MetricsGithubMetric>}
     * @memberof FindManyMetricsGithubMetricResponse
     */
    'metricsGithubMetrics': Array<MetricsGithubMetric>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManyMetricsGithubMetricResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface FindManyMetricsGithubRepositoryResponse
 */
export interface FindManyMetricsGithubRepositoryResponse {
    /**
     * 
     * @type {Array<MetricsGithubRepository>}
     * @memberof FindManyMetricsGithubRepositoryResponse
     */
    'metricsGithubRepositories': Array<MetricsGithubRepository>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManyMetricsGithubRepositoryResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface FindManyMetricsGithubRepositoryStatisticsResponse
 */
export interface FindManyMetricsGithubRepositoryStatisticsResponse {
    /**
     * 
     * @type {Array<MetricsGithubRepositoryStatisticsDto>}
     * @memberof FindManyMetricsGithubRepositoryStatisticsResponse
     */
    'metricsGithubRepositoryStatistics': Array<MetricsGithubRepositoryStatisticsDto>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManyMetricsGithubRepositoryStatisticsResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface FindManyMetricsGithubTeamRepositoryResponse
 */
export interface FindManyMetricsGithubTeamRepositoryResponse {
    /**
     * 
     * @type {Array<MetricsGithubTeamRepositoryDto>}
     * @memberof FindManyMetricsGithubTeamRepositoryResponse
     */
    'metricsGithubTeamRepositories': Array<MetricsGithubTeamRepositoryDto>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManyMetricsGithubTeamRepositoryResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface FindManyMetricsGithubTeamResponse
 */
export interface FindManyMetricsGithubTeamResponse {
    /**
     * 
     * @type {Array<MetricsGithubTeamDto>}
     * @memberof FindManyMetricsGithubTeamResponse
     */
    'metricsGithubTeams': Array<MetricsGithubTeamDto>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManyMetricsGithubTeamResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface FindManyMetricsGithubTeamUserResponse
 */
export interface FindManyMetricsGithubTeamUserResponse {
    /**
     * 
     * @type {Array<MetricsGithubTeamUserDto>}
     * @memberof FindManyMetricsGithubTeamUserResponse
     */
    'metricsGithubTeamUsers': Array<MetricsGithubTeamUserDto>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManyMetricsGithubTeamUserResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface FindManyMetricsGithubUserRepositoryResponse
 */
export interface FindManyMetricsGithubUserRepositoryResponse {
    /**
     * 
     * @type {Array<MetricsGithubUserRepository>}
     * @memberof FindManyMetricsGithubUserRepositoryResponse
     */
    'metricsGithubUserRepositories': Array<MetricsGithubUserRepository>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManyMetricsGithubUserRepositoryResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface FindManyMetricsGithubUserResponse
 */
export interface FindManyMetricsGithubUserResponse {
    /**
     * 
     * @type {Array<MetricsGithubUser>}
     * @memberof FindManyMetricsGithubUserResponse
     */
    'metricsGithubUsers': Array<MetricsGithubUser>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManyMetricsGithubUserResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface FindManyMetricsGithubUserStatisticsResponse
 */
export interface FindManyMetricsGithubUserStatisticsResponse {
    /**
     * 
     * @type {Array<MetricsGithubUserStatisticsDto>}
     * @memberof FindManyMetricsGithubUserStatisticsResponse
     */
    'metricsGithubUserStatistics': Array<MetricsGithubUserStatisticsDto>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManyMetricsGithubUserStatisticsResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface FindManyMetricsUserResponse
 */
export interface FindManyMetricsUserResponse {
    /**
     * 
     * @type {Array<MetricsUserDto>}
     * @memberof FindManyMetricsUserResponse
     */
    'metricsUsers': Array<MetricsUserDto>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManyMetricsUserResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface FindManyNotificationResponse
 */
export interface FindManyNotificationResponse {
    /**
     * 
     * @type {Array<NotificationsEvent>}
     * @memberof FindManyNotificationResponse
     */
    'notifications': Array<NotificationsEvent>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManyNotificationResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface FindManyResponseMeta
 */
export interface FindManyResponseMeta {
    /**
     * 
     * @type {number}
     * @memberof FindManyResponseMeta
     */
    'curPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof FindManyResponseMeta
     */
    'perPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof FindManyResponseMeta
     */
    'totalResults': number;
}
/**
 * 
 * @export
 * @interface FindManySsoEmailTemplateResponse
 */
export interface FindManySsoEmailTemplateResponse {
    /**
     * 
     * @type {Array<SsoEmailTemplateDto>}
     * @memberof FindManySsoEmailTemplateResponse
     */
    'ssoEmailTemplates': Array<SsoEmailTemplateDto>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManySsoEmailTemplateResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface FindManySsoPublicTenantResponse
 */
export interface FindManySsoPublicTenantResponse {
    /**
     * 
     * @type {Array<SsoPublicTenantDto>}
     * @memberof FindManySsoPublicTenantResponse
     */
    'ssoPublicTenants': Array<SsoPublicTenantDto>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManySsoPublicTenantResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface FindManySsoRefreshSessionResponse
 */
export interface FindManySsoRefreshSessionResponse {
    /**
     * 
     * @type {Array<SsoRefreshSessionDto>}
     * @memberof FindManySsoRefreshSessionResponse
     */
    'ssoRefreshSessions': Array<SsoRefreshSessionDto>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManySsoRefreshSessionResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface FindManySsoRoleResponse
 */
export interface FindManySsoRoleResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof FindManySsoRoleResponse
     */
    'userAvailableRoles': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FindManySsoRoleResponse
     */
    'userDefaultRoles': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FindManySsoRoleResponse
     */
    'adminDefaultRoles': Array<string>;
}
/**
 * 
 * @export
 * @interface FindManySsoTenantResponse
 */
export interface FindManySsoTenantResponse {
    /**
     * 
     * @type {Array<SsoTenantDto>}
     * @memberof FindManySsoTenantResponse
     */
    'ssoTenants': Array<SsoTenantDto>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManySsoTenantResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface FindManySsoUserResponse
 */
export interface FindManySsoUserResponse {
    /**
     * 
     * @type {Array<SsoUserDto>}
     * @memberof FindManySsoUserResponse
     */
    'ssoUsers': Array<SsoUserDto>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManySsoUserResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface FindManyWebhookLogResponse
 */
export interface FindManyWebhookLogResponse {
    /**
     * 
     * @type {Array<WebhookLog>}
     * @memberof FindManyWebhookLogResponse
     */
    'webhookLogs': Array<WebhookLog>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManyWebhookLogResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface FindManyWebhookResponse
 */
export interface FindManyWebhookResponse {
    /**
     * 
     * @type {Array<Webhook>}
     * @memberof FindManyWebhookResponse
     */
    'webhooks': Array<Webhook>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManyWebhookResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface ForgotPasswordArgs
 */
export interface ForgotPasswordArgs {
    /**
     * 
     * @type {string}
     * @memberof ForgotPasswordArgs
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof ForgotPasswordArgs
     */
    'redirectUri'?: string;
}
/**
 * 
 * @export
 * @interface MetricsEntities
 */
export interface MetricsEntities {
    /**
     * 
     * @type {MetricsGithubMetricScalarFieldEnum}
     * @memberof MetricsEntities
     */
    'MetricsGithubMetric': MetricsGithubMetricScalarFieldEnum;
    /**
     * 
     * @type {MetricsGithubRepositoryScalarFieldEnum}
     * @memberof MetricsEntities
     */
    'MetricsGithubRepository': MetricsGithubRepositoryScalarFieldEnum;
    /**
     * 
     * @type {MetricsGithubUserScalarFieldEnum}
     * @memberof MetricsEntities
     */
    'MetricsGithubUser': MetricsGithubUserScalarFieldEnum;
    /**
     * 
     * @type {MetricsGithubUserRepositoryScalarFieldEnum}
     * @memberof MetricsEntities
     */
    'MetricsGithubUserRepository': MetricsGithubUserRepositoryScalarFieldEnum;
    /**
     * 
     * @type {MetricsUserScalarFieldEnum}
     * @memberof MetricsEntities
     */
    'MetricsUser': MetricsUserScalarFieldEnum;
    /**
     * 
     * @type {MetricsGithubRepositoryStatisticsScalarFieldEnum}
     * @memberof MetricsEntities
     */
    'MetricsGithubRepositoryStatistics': MetricsGithubRepositoryStatisticsScalarFieldEnum;
    /**
     * 
     * @type {MetricsGithubTeamScalarFieldEnum}
     * @memberof MetricsEntities
     */
    'MetricsGithubTeam': MetricsGithubTeamScalarFieldEnum;
    /**
     * 
     * @type {MetricsGithubTeamRepositoryScalarFieldEnum}
     * @memberof MetricsEntities
     */
    'MetricsGithubTeamRepository': MetricsGithubTeamRepositoryScalarFieldEnum;
    /**
     * 
     * @type {MetricsGithubTeamUserScalarFieldEnum}
     * @memberof MetricsEntities
     */
    'MetricsGithubTeamUser': MetricsGithubTeamUserScalarFieldEnum;
    /**
     * 
     * @type {MetricsGithubUserStatisticsScalarFieldEnum}
     * @memberof MetricsEntities
     */
    'MetricsGithubUserStatistics': MetricsGithubUserStatisticsScalarFieldEnum;
}


/**
 * 
 * @export
 * @interface MetricsError
 */
export interface MetricsError {
    /**
     * Metrics error (METRICS-000), Tenant ID not set (METRICS-003), User ID not set (METRICS-002), Forbidden (METRICS-001), User not found (METRICS-004)
     * @type {string}
     * @memberof MetricsError
     */
    'message': string;
    /**
     * 
     * @type {MetricsErrorEnum}
     * @memberof MetricsError
     */
    'code': MetricsErrorEnum;
    /**
     * 
     * @type {object}
     * @memberof MetricsError
     */
    'metadata'?: object;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const MetricsErrorEnum = {
    Metrics000: 'METRICS-000',
    Metrics001: 'METRICS-001',
    Metrics002: 'METRICS-002',
    Metrics003: 'METRICS-003',
    Metrics004: 'METRICS-004'
} as const;

export type MetricsErrorEnum = typeof MetricsErrorEnum[keyof typeof MetricsErrorEnum];


/**
 * 
 * @export
 * @interface MetricsGithubMetric
 */
export interface MetricsGithubMetric {
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubMetric
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubMetric
     */
    'repositoryId': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubMetric
     */
    'metricName': string;
    /**
     * 
     * @type {number}
     * @memberof MetricsGithubMetric
     */
    'metricValue': number;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubMetric
     */
    'recordedAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubMetric
     */
    'createdBy': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubMetric
     */
    'updatedBy': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubMetric
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubMetric
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubMetric
     */
    'tenantId': string;
    /**
     * 
     * @type {MetricsUser}
     * @memberof MetricsGithubMetric
     */
    'MetricsUser_MetricsGithubMetric_createdByToMetricsUser'?: MetricsUser;
    /**
     * 
     * @type {MetricsGithubRepository}
     * @memberof MetricsGithubMetric
     */
    'MetricsGithubRepository'?: MetricsGithubRepository;
    /**
     * 
     * @type {MetricsUser}
     * @memberof MetricsGithubMetric
     */
    'MetricsUser_MetricsGithubMetric_updatedByToMetricsUser'?: MetricsUser;
}
/**
 * 
 * @export
 * @interface MetricsGithubMetricControllerFindMany400Response
 */
export interface MetricsGithubMetricControllerFindMany400Response {
    /**
     * Validation error (VALIDATION-000)
     * @type {string}
     * @memberof MetricsGithubMetricControllerFindMany400Response
     */
    'message': string;
    /**
     * 
     * @type {ValidationErrorEnum}
     * @memberof MetricsGithubMetricControllerFindMany400Response
     */
    'code': ValidationErrorEnum;
    /**
     * 
     * @type {Array<ValidationErrorMetadata>}
     * @memberof MetricsGithubMetricControllerFindMany400Response
     */
    'metadata'?: Array<ValidationErrorMetadata>;
}


/**
 * 
 * @export
 * @interface MetricsGithubMetricDto
 */
export interface MetricsGithubMetricDto {
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubMetricDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubMetricDto
     */
    'metricName': string;
    /**
     * 
     * @type {number}
     * @memberof MetricsGithubMetricDto
     */
    'metricValue': number;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubMetricDto
     */
    'recordedAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubMetricDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubMetricDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubMetricDto
     */
    'tenantId': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const MetricsGithubMetricScalarFieldEnum = {
    Id: 'id',
    RepositoryId: 'repositoryId',
    MetricName: 'metricName',
    MetricValue: 'metricValue',
    RecordedAt: 'recordedAt',
    CreatedBy: 'createdBy',
    UpdatedBy: 'updatedBy',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt',
    TenantId: 'tenantId'
} as const;

export type MetricsGithubMetricScalarFieldEnum = typeof MetricsGithubMetricScalarFieldEnum[keyof typeof MetricsGithubMetricScalarFieldEnum];


/**
 * 
 * @export
 * @interface MetricsGithubRepository
 */
export interface MetricsGithubRepository {
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubRepository
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubRepository
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubRepository
     */
    'owner': string;
    /**
     * 
     * @type {boolean}
     * @memberof MetricsGithubRepository
     */
    'private': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MetricsGithubRepository
     */
    'fork': boolean;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubRepository
     */
    'createdBy': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubRepository
     */
    'updatedBy': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubRepository
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubRepository
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubRepository
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubRepository
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubRepository
     */
    'url': string | null;
    /**
     * 
     * @type {Array<MetricsGithubMetric>}
     * @memberof MetricsGithubRepository
     */
    'MetricsGithubMetric'?: Array<MetricsGithubMetric>;
    /**
     * 
     * @type {MetricsUser}
     * @memberof MetricsGithubRepository
     */
    'MetricsUser_MetricsGithubRepository_createdByToMetricsUser'?: MetricsUser;
    /**
     * 
     * @type {MetricsUser}
     * @memberof MetricsGithubRepository
     */
    'MetricsUser_MetricsGithubRepository_updatedByToMetricsUser'?: MetricsUser;
    /**
     * 
     * @type {Array<MetricsGithubRepositoryStatistics>}
     * @memberof MetricsGithubRepository
     */
    'MetricsGithubRepositoryStatistics'?: Array<MetricsGithubRepositoryStatistics>;
    /**
     * 
     * @type {Array<MetricsGithubTeamRepository>}
     * @memberof MetricsGithubRepository
     */
    'MetricsGithubTeamRepository'?: Array<MetricsGithubTeamRepository>;
    /**
     * 
     * @type {Array<MetricsGithubUserRepository>}
     * @memberof MetricsGithubRepository
     */
    'MetricsGithubUserRepository'?: Array<MetricsGithubUserRepository>;
}
/**
 * 
 * @export
 * @interface MetricsGithubRepositoryDto
 */
export interface MetricsGithubRepositoryDto {
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubRepositoryDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubRepositoryDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubRepositoryDto
     */
    'owner': string;
    /**
     * 
     * @type {boolean}
     * @memberof MetricsGithubRepositoryDto
     */
    'private': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MetricsGithubRepositoryDto
     */
    'fork': boolean;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubRepositoryDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubRepositoryDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubRepositoryDto
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubRepositoryDto
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubRepositoryDto
     */
    'url': string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const MetricsGithubRepositoryScalarFieldEnum = {
    Id: 'id',
    Name: 'name',
    Owner: 'owner',
    Private: 'private',
    Fork: 'fork',
    CreatedBy: 'createdBy',
    UpdatedBy: 'updatedBy',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt',
    TenantId: 'tenantId',
    Description: 'description',
    Url: 'url'
} as const;

export type MetricsGithubRepositoryScalarFieldEnum = typeof MetricsGithubRepositoryScalarFieldEnum[keyof typeof MetricsGithubRepositoryScalarFieldEnum];


/**
 * 
 * @export
 * @interface MetricsGithubRepositoryStatistics
 */
export interface MetricsGithubRepositoryStatistics {
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubRepositoryStatistics
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubRepositoryStatistics
     */
    'repositoryId': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubRepositoryStatistics
     */
    'periodType': string;
    /**
     * 
     * @type {number}
     * @memberof MetricsGithubRepositoryStatistics
     */
    'starsCount': number | null;
    /**
     * 
     * @type {number}
     * @memberof MetricsGithubRepositoryStatistics
     */
    'forksCount': number | null;
    /**
     * 
     * @type {number}
     * @memberof MetricsGithubRepositoryStatistics
     */
    'contributorsCount': number | null;
    /**
     * 
     * @type {number}
     * @memberof MetricsGithubRepositoryStatistics
     */
    'commitsCount': number | null;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubRepositoryStatistics
     */
    'lastCommitDate': string | null;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubRepositoryStatistics
     */
    'recordedAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubRepositoryStatistics
     */
    'createdBy': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubRepositoryStatistics
     */
    'updatedBy': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubRepositoryStatistics
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubRepositoryStatistics
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubRepositoryStatistics
     */
    'tenantId': string;
    /**
     * 
     * @type {MetricsUser}
     * @memberof MetricsGithubRepositoryStatistics
     */
    'MetricsUser_MetricsGithubRepositoryStatistics_createdByToMetricsUser'?: MetricsUser;
    /**
     * 
     * @type {MetricsGithubRepository}
     * @memberof MetricsGithubRepositoryStatistics
     */
    'MetricsGithubRepository'?: MetricsGithubRepository;
    /**
     * 
     * @type {MetricsUser}
     * @memberof MetricsGithubRepositoryStatistics
     */
    'MetricsUser_MetricsGithubRepositoryStatistics_updatedByToMetricsUser'?: MetricsUser;
}
/**
 * 
 * @export
 * @interface MetricsGithubRepositoryStatisticsDto
 */
export interface MetricsGithubRepositoryStatisticsDto {
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubRepositoryStatisticsDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubRepositoryStatisticsDto
     */
    'periodType': string;
    /**
     * 
     * @type {number}
     * @memberof MetricsGithubRepositoryStatisticsDto
     */
    'starsCount': number | null;
    /**
     * 
     * @type {number}
     * @memberof MetricsGithubRepositoryStatisticsDto
     */
    'forksCount': number | null;
    /**
     * 
     * @type {number}
     * @memberof MetricsGithubRepositoryStatisticsDto
     */
    'contributorsCount': number | null;
    /**
     * 
     * @type {number}
     * @memberof MetricsGithubRepositoryStatisticsDto
     */
    'commitsCount': number | null;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubRepositoryStatisticsDto
     */
    'lastCommitDate': string | null;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubRepositoryStatisticsDto
     */
    'recordedAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubRepositoryStatisticsDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubRepositoryStatisticsDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubRepositoryStatisticsDto
     */
    'tenantId': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const MetricsGithubRepositoryStatisticsScalarFieldEnum = {
    Id: 'id',
    RepositoryId: 'repositoryId',
    PeriodType: 'periodType',
    StarsCount: 'starsCount',
    ForksCount: 'forksCount',
    ContributorsCount: 'contributorsCount',
    CommitsCount: 'commitsCount',
    LastCommitDate: 'lastCommitDate',
    RecordedAt: 'recordedAt',
    CreatedBy: 'createdBy',
    UpdatedBy: 'updatedBy',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt',
    TenantId: 'tenantId'
} as const;

export type MetricsGithubRepositoryStatisticsScalarFieldEnum = typeof MetricsGithubRepositoryStatisticsScalarFieldEnum[keyof typeof MetricsGithubRepositoryStatisticsScalarFieldEnum];


/**
 * 
 * @export
 * @interface MetricsGithubTeam
 */
export interface MetricsGithubTeam {
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeam
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeam
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeam
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeam
     */
    'createdBy': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeam
     */
    'updatedBy': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeam
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeam
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeam
     */
    'tenantId': string;
    /**
     * 
     * @type {MetricsUser}
     * @memberof MetricsGithubTeam
     */
    'MetricsUser_MetricsGithubTeam_createdByToMetricsUser'?: MetricsUser;
    /**
     * 
     * @type {MetricsUser}
     * @memberof MetricsGithubTeam
     */
    'MetricsUser_MetricsGithubTeam_updatedByToMetricsUser'?: MetricsUser;
    /**
     * 
     * @type {Array<MetricsGithubTeamRepository>}
     * @memberof MetricsGithubTeam
     */
    'MetricsGithubTeamRepository'?: Array<MetricsGithubTeamRepository>;
    /**
     * 
     * @type {Array<MetricsGithubTeamUser>}
     * @memberof MetricsGithubTeam
     */
    'MetricsGithubTeamUser'?: Array<MetricsGithubTeamUser>;
}
/**
 * 
 * @export
 * @interface MetricsGithubTeamDto
 */
export interface MetricsGithubTeamDto {
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeamDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeamDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeamDto
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeamDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeamDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeamDto
     */
    'tenantId': string;
}
/**
 * 
 * @export
 * @interface MetricsGithubTeamRepository
 */
export interface MetricsGithubTeamRepository {
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeamRepository
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeamRepository
     */
    'teamId': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeamRepository
     */
    'repositoryId': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeamRepository
     */
    'createdBy': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeamRepository
     */
    'updatedBy': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeamRepository
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeamRepository
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeamRepository
     */
    'tenantId': string;
    /**
     * 
     * @type {MetricsUser}
     * @memberof MetricsGithubTeamRepository
     */
    'MetricsUser_MetricsGithubTeamRepository_createdByToMetricsUser'?: MetricsUser;
    /**
     * 
     * @type {MetricsGithubRepository}
     * @memberof MetricsGithubTeamRepository
     */
    'MetricsGithubRepository'?: MetricsGithubRepository;
    /**
     * 
     * @type {MetricsGithubTeam}
     * @memberof MetricsGithubTeamRepository
     */
    'MetricsGithubTeam'?: MetricsGithubTeam;
    /**
     * 
     * @type {MetricsUser}
     * @memberof MetricsGithubTeamRepository
     */
    'MetricsUser_MetricsGithubTeamRepository_updatedByToMetricsUser'?: MetricsUser;
}
/**
 * 
 * @export
 * @interface MetricsGithubTeamRepositoryDto
 */
export interface MetricsGithubTeamRepositoryDto {
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeamRepositoryDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeamRepositoryDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeamRepositoryDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeamRepositoryDto
     */
    'tenantId': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const MetricsGithubTeamRepositoryScalarFieldEnum = {
    Id: 'id',
    TeamId: 'teamId',
    RepositoryId: 'repositoryId',
    CreatedBy: 'createdBy',
    UpdatedBy: 'updatedBy',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt',
    TenantId: 'tenantId'
} as const;

export type MetricsGithubTeamRepositoryScalarFieldEnum = typeof MetricsGithubTeamRepositoryScalarFieldEnum[keyof typeof MetricsGithubTeamRepositoryScalarFieldEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const MetricsGithubTeamScalarFieldEnum = {
    Id: 'id',
    Name: 'name',
    Description: 'description',
    CreatedBy: 'createdBy',
    UpdatedBy: 'updatedBy',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt',
    TenantId: 'tenantId'
} as const;

export type MetricsGithubTeamScalarFieldEnum = typeof MetricsGithubTeamScalarFieldEnum[keyof typeof MetricsGithubTeamScalarFieldEnum];


/**
 * 
 * @export
 * @interface MetricsGithubTeamUser
 */
export interface MetricsGithubTeamUser {
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeamUser
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeamUser
     */
    'teamId': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeamUser
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeamUser
     */
    'role': string | null;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeamUser
     */
    'createdBy': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeamUser
     */
    'updatedBy': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeamUser
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeamUser
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeamUser
     */
    'tenantId': string;
    /**
     * 
     * @type {MetricsUser}
     * @memberof MetricsGithubTeamUser
     */
    'MetricsUser_MetricsGithubTeamUser_createdByToMetricsUser'?: MetricsUser;
    /**
     * 
     * @type {MetricsGithubTeam}
     * @memberof MetricsGithubTeamUser
     */
    'MetricsGithubTeam'?: MetricsGithubTeam;
    /**
     * 
     * @type {MetricsUser}
     * @memberof MetricsGithubTeamUser
     */
    'MetricsUser_MetricsGithubTeamUser_updatedByToMetricsUser'?: MetricsUser;
    /**
     * 
     * @type {MetricsGithubUser}
     * @memberof MetricsGithubTeamUser
     */
    'MetricsGithubUser'?: MetricsGithubUser;
}
/**
 * 
 * @export
 * @interface MetricsGithubTeamUserDto
 */
export interface MetricsGithubTeamUserDto {
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeamUserDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeamUserDto
     */
    'role': string | null;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeamUserDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeamUserDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubTeamUserDto
     */
    'tenantId': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const MetricsGithubTeamUserScalarFieldEnum = {
    Id: 'id',
    TeamId: 'teamId',
    UserId: 'userId',
    Role: 'role',
    CreatedBy: 'createdBy',
    UpdatedBy: 'updatedBy',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt',
    TenantId: 'tenantId'
} as const;

export type MetricsGithubTeamUserScalarFieldEnum = typeof MetricsGithubTeamUserScalarFieldEnum[keyof typeof MetricsGithubTeamUserScalarFieldEnum];


/**
 * 
 * @export
 * @interface MetricsGithubUser
 */
export interface MetricsGithubUser {
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUser
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUser
     */
    'login': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUser
     */
    'name': string | null;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUser
     */
    'email': string | null;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUser
     */
    'createdBy': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUser
     */
    'updatedBy': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUser
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUser
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUser
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUser
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUser
     */
    'avatarUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUser
     */
    'websiteUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUser
     */
    'location': string | null;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUser
     */
    'telegramUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUser
     */
    'twitterUrl': string | null;
    /**
     * 
     * @type {Array<MetricsGithubTeamUser>}
     * @memberof MetricsGithubUser
     */
    'MetricsGithubTeamUser'?: Array<MetricsGithubTeamUser>;
    /**
     * 
     * @type {MetricsUser}
     * @memberof MetricsGithubUser
     */
    'MetricsUser_MetricsGithubUser_createdByToMetricsUser'?: MetricsUser;
    /**
     * 
     * @type {MetricsUser}
     * @memberof MetricsGithubUser
     */
    'MetricsUser_MetricsGithubUser_updatedByToMetricsUser'?: MetricsUser;
    /**
     * 
     * @type {Array<MetricsGithubUserRepository>}
     * @memberof MetricsGithubUser
     */
    'MetricsGithubUserRepository'?: Array<MetricsGithubUserRepository>;
    /**
     * 
     * @type {Array<MetricsGithubUserStatistics>}
     * @memberof MetricsGithubUser
     */
    'MetricsGithubUserStatistics'?: Array<MetricsGithubUserStatistics>;
}
/**
 * 
 * @export
 * @interface MetricsGithubUserDto
 */
export interface MetricsGithubUserDto {
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserDto
     */
    'login': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserDto
     */
    'name': string | null;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserDto
     */
    'email': string | null;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserDto
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserDto
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserDto
     */
    'avatarUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserDto
     */
    'websiteUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserDto
     */
    'location': string | null;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserDto
     */
    'telegramUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserDto
     */
    'twitterUrl': string | null;
}
/**
 * 
 * @export
 * @interface MetricsGithubUserRepository
 */
export interface MetricsGithubUserRepository {
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserRepository
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserRepository
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserRepository
     */
    'repositoryId': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserRepository
     */
    'role': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserRepository
     */
    'createdBy': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserRepository
     */
    'updatedBy': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserRepository
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserRepository
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserRepository
     */
    'tenantId': string;
    /**
     * 
     * @type {MetricsUser}
     * @memberof MetricsGithubUserRepository
     */
    'MetricsUser_MetricsGithubUserRepository_createdByToMetricsUser'?: MetricsUser;
    /**
     * 
     * @type {MetricsGithubRepository}
     * @memberof MetricsGithubUserRepository
     */
    'MetricsGithubRepository'?: MetricsGithubRepository;
    /**
     * 
     * @type {MetricsUser}
     * @memberof MetricsGithubUserRepository
     */
    'MetricsUser_MetricsGithubUserRepository_updatedByToMetricsUser'?: MetricsUser;
    /**
     * 
     * @type {MetricsGithubUser}
     * @memberof MetricsGithubUserRepository
     */
    'MetricsGithubUser'?: MetricsGithubUser;
}
/**
 * 
 * @export
 * @interface MetricsGithubUserRepositoryDto
 */
export interface MetricsGithubUserRepositoryDto {
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserRepositoryDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserRepositoryDto
     */
    'role': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserRepositoryDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserRepositoryDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserRepositoryDto
     */
    'tenantId': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const MetricsGithubUserRepositoryScalarFieldEnum = {
    Id: 'id',
    UserId: 'userId',
    RepositoryId: 'repositoryId',
    Role: 'role',
    CreatedBy: 'createdBy',
    UpdatedBy: 'updatedBy',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt',
    TenantId: 'tenantId'
} as const;

export type MetricsGithubUserRepositoryScalarFieldEnum = typeof MetricsGithubUserRepositoryScalarFieldEnum[keyof typeof MetricsGithubUserRepositoryScalarFieldEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const MetricsGithubUserScalarFieldEnum = {
    Id: 'id',
    Login: 'login',
    Name: 'name',
    Email: 'email',
    CreatedBy: 'createdBy',
    UpdatedBy: 'updatedBy',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt',
    TenantId: 'tenantId',
    Description: 'description',
    AvatarUrl: 'avatarUrl',
    WebsiteUrl: 'websiteUrl',
    Location: 'location',
    TelegramUrl: 'telegramUrl',
    TwitterUrl: 'twitterUrl'
} as const;

export type MetricsGithubUserScalarFieldEnum = typeof MetricsGithubUserScalarFieldEnum[keyof typeof MetricsGithubUserScalarFieldEnum];


/**
 * 
 * @export
 * @interface MetricsGithubUserStatistics
 */
export interface MetricsGithubUserStatistics {
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserStatistics
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserStatistics
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserStatistics
     */
    'periodType': string;
    /**
     * 
     * @type {number}
     * @memberof MetricsGithubUserStatistics
     */
    'followersCount': number | null;
    /**
     * 
     * @type {number}
     * @memberof MetricsGithubUserStatistics
     */
    'followingCount': number | null;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserStatistics
     */
    'recordedAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserStatistics
     */
    'createdBy': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserStatistics
     */
    'updatedBy': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserStatistics
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserStatistics
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserStatistics
     */
    'tenantId': string;
    /**
     * 
     * @type {MetricsUser}
     * @memberof MetricsGithubUserStatistics
     */
    'MetricsUser_MetricsGithubUserStatistics_createdByToMetricsUser'?: MetricsUser;
    /**
     * 
     * @type {MetricsUser}
     * @memberof MetricsGithubUserStatistics
     */
    'MetricsUser_MetricsGithubUserStatistics_updatedByToMetricsUser'?: MetricsUser;
    /**
     * 
     * @type {MetricsGithubUser}
     * @memberof MetricsGithubUserStatistics
     */
    'MetricsGithubUser'?: MetricsGithubUser;
}
/**
 * 
 * @export
 * @interface MetricsGithubUserStatisticsDto
 */
export interface MetricsGithubUserStatisticsDto {
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserStatisticsDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserStatisticsDto
     */
    'periodType': string;
    /**
     * 
     * @type {number}
     * @memberof MetricsGithubUserStatisticsDto
     */
    'followersCount': number | null;
    /**
     * 
     * @type {number}
     * @memberof MetricsGithubUserStatisticsDto
     */
    'followingCount': number | null;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserStatisticsDto
     */
    'recordedAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserStatisticsDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserStatisticsDto
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsGithubUserStatisticsDto
     */
    'tenantId': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const MetricsGithubUserStatisticsScalarFieldEnum = {
    Id: 'id',
    UserId: 'userId',
    PeriodType: 'periodType',
    FollowersCount: 'followersCount',
    FollowingCount: 'followingCount',
    RecordedAt: 'recordedAt',
    CreatedBy: 'createdBy',
    UpdatedBy: 'updatedBy',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt',
    TenantId: 'tenantId'
} as const;

export type MetricsGithubUserStatisticsScalarFieldEnum = typeof MetricsGithubUserStatisticsScalarFieldEnum[keyof typeof MetricsGithubUserStatisticsScalarFieldEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const MetricsRole = {
    Admin: 'Admin',
    User: 'User'
} as const;

export type MetricsRole = typeof MetricsRole[keyof typeof MetricsRole];


/**
 * 
 * @export
 * @interface MetricsUser
 */
export interface MetricsUser {
    /**
     * 
     * @type {string}
     * @memberof MetricsUser
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsUser
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsUser
     */
    'externalUserId': string;
    /**
     * 
     * @type {MetricsRole}
     * @memberof MetricsUser
     */
    'userRole': MetricsRole;
    /**
     * 
     * @type {string}
     * @memberof MetricsUser
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsUser
     */
    'updatedAt': string;
    /**
     * 
     * @type {Array<MetricsGithubMetric>}
     * @memberof MetricsUser
     */
    'MetricsGithubMetric_MetricsGithubMetric_createdByToMetricsUser'?: Array<MetricsGithubMetric>;
    /**
     * 
     * @type {Array<MetricsGithubMetric>}
     * @memberof MetricsUser
     */
    'MetricsGithubMetric_MetricsGithubMetric_updatedByToMetricsUser'?: Array<MetricsGithubMetric>;
    /**
     * 
     * @type {Array<MetricsGithubRepository>}
     * @memberof MetricsUser
     */
    'MetricsGithubRepository_MetricsGithubRepository_createdByToMetricsUser'?: Array<MetricsGithubRepository>;
    /**
     * 
     * @type {Array<MetricsGithubRepository>}
     * @memberof MetricsUser
     */
    'MetricsGithubRepository_MetricsGithubRepository_updatedByToMetricsUser'?: Array<MetricsGithubRepository>;
    /**
     * 
     * @type {Array<MetricsGithubRepositoryStatistics>}
     * @memberof MetricsUser
     */
    'MetricsGithubRepositoryStatistics_MetricsGithubRepositoryStatistics_createdByToMetricsUser'?: Array<MetricsGithubRepositoryStatistics>;
    /**
     * 
     * @type {Array<MetricsGithubRepositoryStatistics>}
     * @memberof MetricsUser
     */
    'MetricsGithubRepositoryStatistics_MetricsGithubRepositoryStatistics_updatedByToMetricsUser'?: Array<MetricsGithubRepositoryStatistics>;
    /**
     * 
     * @type {Array<MetricsGithubTeam>}
     * @memberof MetricsUser
     */
    'MetricsGithubTeam_MetricsGithubTeam_createdByToMetricsUser'?: Array<MetricsGithubTeam>;
    /**
     * 
     * @type {Array<MetricsGithubTeam>}
     * @memberof MetricsUser
     */
    'MetricsGithubTeam_MetricsGithubTeam_updatedByToMetricsUser'?: Array<MetricsGithubTeam>;
    /**
     * 
     * @type {Array<MetricsGithubTeamRepository>}
     * @memberof MetricsUser
     */
    'MetricsGithubTeamRepository_MetricsGithubTeamRepository_createdByToMetricsUser'?: Array<MetricsGithubTeamRepository>;
    /**
     * 
     * @type {Array<MetricsGithubTeamRepository>}
     * @memberof MetricsUser
     */
    'MetricsGithubTeamRepository_MetricsGithubTeamRepository_updatedByToMetricsUser'?: Array<MetricsGithubTeamRepository>;
    /**
     * 
     * @type {Array<MetricsGithubTeamUser>}
     * @memberof MetricsUser
     */
    'MetricsGithubTeamUser_MetricsGithubTeamUser_createdByToMetricsUser'?: Array<MetricsGithubTeamUser>;
    /**
     * 
     * @type {Array<MetricsGithubTeamUser>}
     * @memberof MetricsUser
     */
    'MetricsGithubTeamUser_MetricsGithubTeamUser_updatedByToMetricsUser'?: Array<MetricsGithubTeamUser>;
    /**
     * 
     * @type {Array<MetricsGithubUser>}
     * @memberof MetricsUser
     */
    'MetricsGithubUser_MetricsGithubUser_createdByToMetricsUser'?: Array<MetricsGithubUser>;
    /**
     * 
     * @type {Array<MetricsGithubUser>}
     * @memberof MetricsUser
     */
    'MetricsGithubUser_MetricsGithubUser_updatedByToMetricsUser'?: Array<MetricsGithubUser>;
    /**
     * 
     * @type {Array<MetricsGithubUserRepository>}
     * @memberof MetricsUser
     */
    'MetricsGithubUserRepository_MetricsGithubUserRepository_createdByToMetricsUser'?: Array<MetricsGithubUserRepository>;
    /**
     * 
     * @type {Array<MetricsGithubUserRepository>}
     * @memberof MetricsUser
     */
    'MetricsGithubUserRepository_MetricsGithubUserRepository_updatedByToMetricsUser'?: Array<MetricsGithubUserRepository>;
    /**
     * 
     * @type {Array<MetricsGithubUserStatistics>}
     * @memberof MetricsUser
     */
    'MetricsGithubUserStatistics_MetricsGithubUserStatistics_createdByToMetricsUser'?: Array<MetricsGithubUserStatistics>;
    /**
     * 
     * @type {Array<MetricsGithubUserStatistics>}
     * @memberof MetricsUser
     */
    'MetricsGithubUserStatistics_MetricsGithubUserStatistics_updatedByToMetricsUser'?: Array<MetricsGithubUserStatistics>;
}


/**
 * 
 * @export
 * @interface MetricsUserDto
 */
export interface MetricsUserDto {
    /**
     * 
     * @type {string}
     * @memberof MetricsUserDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsUserDto
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsUserDto
     */
    'externalUserId': string;
    /**
     * 
     * @type {MetricsRole}
     * @memberof MetricsUserDto
     */
    'userRole': MetricsRole;
    /**
     * 
     * @type {string}
     * @memberof MetricsUserDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsUserDto
     */
    'updatedAt': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const MetricsUserScalarFieldEnum = {
    Id: 'id',
    TenantId: 'tenantId',
    ExternalUserId: 'externalUserId',
    UserRole: 'userRole',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;

export type MetricsUserScalarFieldEnum = typeof MetricsUserScalarFieldEnum[keyof typeof MetricsUserScalarFieldEnum];


/**
 * 
 * @export
 * @interface NotificationsControllerFindMany400Response
 */
export interface NotificationsControllerFindMany400Response {
    /**
     * Validation error (VALIDATION-000)
     * @type {string}
     * @memberof NotificationsControllerFindMany400Response
     */
    'message': string;
    /**
     * 
     * @type {ValidationErrorEnum}
     * @memberof NotificationsControllerFindMany400Response
     */
    'code': ValidationErrorEnum;
    /**
     * 
     * @type {Array<ValidationErrorMetadata>}
     * @memberof NotificationsControllerFindMany400Response
     */
    'metadata'?: Array<ValidationErrorMetadata>;
}


/**
 * 
 * @export
 * @interface NotificationsEntities
 */
export interface NotificationsEntities {
    /**
     * 
     * @type {NotificationsUserScalarFieldEnum}
     * @memberof NotificationsEntities
     */
    'NotificationsUser': NotificationsUserScalarFieldEnum;
    /**
     * 
     * @type {NotificationsEventScalarFieldEnum}
     * @memberof NotificationsEntities
     */
    'NotificationsEvent': NotificationsEventScalarFieldEnum;
}


/**
 * 
 * @export
 * @interface NotificationsError
 */
export interface NotificationsError {
    /**
     * Notifications error (NOTIFICATIONS-000), Tenant ID not set (NOTIFICATIONS-001), User ID not set (NOTIFICATIONS-002), Forbidden (NOTIFICATIONS-003)
     * @type {string}
     * @memberof NotificationsError
     */
    'message': string;
    /**
     * 
     * @type {NotificationsErrorEnum}
     * @memberof NotificationsError
     */
    'code': NotificationsErrorEnum;
    /**
     * 
     * @type {object}
     * @memberof NotificationsError
     */
    'metadata'?: object;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const NotificationsErrorEnum = {
    Notifications000: 'NOTIFICATIONS-000',
    Notifications001: 'NOTIFICATIONS-001',
    Notifications002: 'NOTIFICATIONS-002',
    Notifications003: 'NOTIFICATIONS-003'
} as const;

export type NotificationsErrorEnum = typeof NotificationsErrorEnum[keyof typeof NotificationsErrorEnum];


/**
 * 
 * @export
 * @interface NotificationsEvent
 */
export interface NotificationsEvent {
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'operationName': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'subject': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'html': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'text': string | null;
    /**
     * 
     * @type {number}
     * @memberof NotificationsEvent
     */
    'attempt': number;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationsEvent
     */
    'used': boolean;
    /**
     * 
     * @type {object}
     * @memberof NotificationsEvent
     */
    'error': object | null;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'senderUserId': string | null;
    /**
     * 
     * @type {object}
     * @memberof NotificationsEvent
     */
    'senderData': object | null;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'recipientGroupId': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'recipientUserId': string;
    /**
     * 
     * @type {object}
     * @memberof NotificationsEvent
     */
    'recipientData': object | null;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'externalTenantId': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'updatedAt': string;
    /**
     * 
     * @type {NotificationsUser}
     * @memberof NotificationsEvent
     */
    'NotificationsUser_NotificationsEvent_recipientUserIdToNotificationsUser'?: NotificationsUser;
    /**
     * 
     * @type {NotificationsUser}
     * @memberof NotificationsEvent
     */
    'NotificationsUser_NotificationsEvent_senderUserIdToNotificationsUser'?: NotificationsUser | null;
}
/**
 * 
 * @export
 * @interface NotificationsEventDto
 */
export interface NotificationsEventDto {
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'operationName': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'subject': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'html': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'text': string | null;
    /**
     * 
     * @type {number}
     * @memberof NotificationsEventDto
     */
    'attempt': number;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationsEventDto
     */
    'used': boolean;
    /**
     * 
     * @type {object}
     * @memberof NotificationsEventDto
     */
    'error': object | null;
    /**
     * 
     * @type {object}
     * @memberof NotificationsEventDto
     */
    'senderData': object | null;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'recipientGroupId': string;
    /**
     * 
     * @type {object}
     * @memberof NotificationsEventDto
     */
    'recipientData': object | null;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'externalTenantId': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const NotificationsEventScalarFieldEnum = {
    Id: 'id',
    Type: 'type',
    OperationName: 'operationName',
    Subject: 'subject',
    Html: 'html',
    Text: 'text',
    Attempt: 'attempt',
    Used: 'used',
    Error: 'error',
    SenderUserId: 'senderUserId',
    SenderData: 'senderData',
    RecipientGroupId: 'recipientGroupId',
    RecipientUserId: 'recipientUserId',
    RecipientData: 'recipientData',
    ExternalTenantId: 'externalTenantId',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;

export type NotificationsEventScalarFieldEnum = typeof NotificationsEventScalarFieldEnum[keyof typeof NotificationsEventScalarFieldEnum];


/**
 * 
 * @export
 * @interface NotificationsUser
 */
export interface NotificationsUser {
    /**
     * 
     * @type {string}
     * @memberof NotificationsUser
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsUser
     */
    'externalTenantId': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsUser
     */
    'externalUserId': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsUser
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsUser
     */
    'updatedAt': string;
    /**
     * 
     * @type {Array<NotificationsEvent>}
     * @memberof NotificationsUser
     */
    'NotificationsEvent_NotificationsEvent_recipientUserIdToNotificationsUser'?: Array<NotificationsEvent>;
    /**
     * 
     * @type {Array<NotificationsEvent>}
     * @memberof NotificationsUser
     */
    'NotificationsEvent_NotificationsEvent_senderUserIdToNotificationsUser'?: Array<NotificationsEvent>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const NotificationsUserScalarFieldEnum = {
    Id: 'id',
    ExternalTenantId: 'externalTenantId',
    ExternalUserId: 'externalUserId',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;

export type NotificationsUserScalarFieldEnum = typeof NotificationsUserScalarFieldEnum[keyof typeof NotificationsUserScalarFieldEnum];


/**
 * 
 * @export
 * @interface OAuthProvider
 */
export interface OAuthProvider {
    /**
     * 
     * @type {string}
     * @memberof OAuthProvider
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OAuthProvider
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof OAuthProvider
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof OAuthProvider
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof OAuthProvider
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof OAuthProvider
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface RefreshTokensResponse
 */
export interface RefreshTokensResponse {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokensResponse
     */
    'fingerprint': string;
    /**
     * 
     * @type {string}
     * @memberof RefreshTokensResponse
     */
    'refreshToken'?: string;
}
/**
 * 
 * @export
 * @interface SendInvitationLinksArgs
 */
export interface SendInvitationLinksArgs {
    /**
     * 
     * @type {string}
     * @memberof SendInvitationLinksArgs
     */
    'emails': string;
}
/**
 * 
 * @export
 * @interface SignInArgs
 */
export interface SignInArgs {
    /**
     * 
     * @type {string}
     * @memberof SignInArgs
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SignInArgs
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof SignInArgs
     */
    'fingerprint': string;
}
/**
 * 
 * @export
 * @interface SignOutArgs
 */
export interface SignOutArgs {
    /**
     * 
     * @type {string}
     * @memberof SignOutArgs
     */
    'refreshToken'?: string;
}
/**
 * 
 * @export
 * @interface SignUpArgs
 */
export interface SignUpArgs {
    /**
     * 
     * @type {string}
     * @memberof SignUpArgs
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpArgs
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpArgs
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpArgs
     */
    'confirmPassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpArgs
     */
    'fingerprint': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpArgs
     */
    'redirectUri'?: string;
    /**
     * 
     * @type {object}
     * @memberof SignUpArgs
     */
    'appData'?: object;
}
/**
 * 
 * @export
 * @interface SsoControllerSignIn400Response
 */
export interface SsoControllerSignIn400Response {
    /**
     * Validation error (VALIDATION-000)
     * @type {string}
     * @memberof SsoControllerSignIn400Response
     */
    'message': string;
    /**
     * 
     * @type {ValidationErrorEnum}
     * @memberof SsoControllerSignIn400Response
     */
    'code': ValidationErrorEnum;
    /**
     * 
     * @type {Array<ValidationErrorMetadata>}
     * @memberof SsoControllerSignIn400Response
     */
    'metadata'?: Array<ValidationErrorMetadata>;
}


/**
 * 
 * @export
 * @interface SsoEmailTemplate
 */
export interface SsoEmailTemplate {
    /**
     * 
     * @type {string}
     * @memberof SsoEmailTemplate
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SsoEmailTemplate
     */
    'subject': string;
    /**
     * 
     * @type {object}
     * @memberof SsoEmailTemplate
     */
    'subjectLocale': object | null;
    /**
     * 
     * @type {string}
     * @memberof SsoEmailTemplate
     */
    'text': string;
    /**
     * 
     * @type {object}
     * @memberof SsoEmailTemplate
     */
    'textLocale': object | null;
    /**
     * 
     * @type {string}
     * @memberof SsoEmailTemplate
     */
    'html': string;
    /**
     * 
     * @type {object}
     * @memberof SsoEmailTemplate
     */
    'htmlLocale': object | null;
    /**
     * 
     * @type {string}
     * @memberof SsoEmailTemplate
     */
    'operationName': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoEmailTemplate
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof SsoEmailTemplate
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SsoEmailTemplate
     */
    'updatedAt': string;
    /**
     * 
     * @type {SsoTenant}
     * @memberof SsoEmailTemplate
     */
    'SsoTenant'?: SsoTenant;
}
/**
 * 
 * @export
 * @interface SsoEmailTemplateDto
 */
export interface SsoEmailTemplateDto {
    /**
     * 
     * @type {string}
     * @memberof SsoEmailTemplateDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SsoEmailTemplateDto
     */
    'subject': string;
    /**
     * 
     * @type {object}
     * @memberof SsoEmailTemplateDto
     */
    'subjectLocale': object | null;
    /**
     * 
     * @type {string}
     * @memberof SsoEmailTemplateDto
     */
    'text': string;
    /**
     * 
     * @type {object}
     * @memberof SsoEmailTemplateDto
     */
    'textLocale': object | null;
    /**
     * 
     * @type {string}
     * @memberof SsoEmailTemplateDto
     */
    'html': string;
    /**
     * 
     * @type {object}
     * @memberof SsoEmailTemplateDto
     */
    'htmlLocale': object | null;
    /**
     * 
     * @type {string}
     * @memberof SsoEmailTemplateDto
     */
    'operationName': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoEmailTemplateDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SsoEmailTemplateDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SsoEmailTemplateScalarFieldEnum = {
    Id: 'id',
    Subject: 'subject',
    SubjectLocale: 'subjectLocale',
    Text: 'text',
    TextLocale: 'textLocale',
    Html: 'html',
    HtmlLocale: 'htmlLocale',
    OperationName: 'operationName',
    TenantId: 'tenantId',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;

export type SsoEmailTemplateScalarFieldEnum = typeof SsoEmailTemplateScalarFieldEnum[keyof typeof SsoEmailTemplateScalarFieldEnum];


/**
 * 
 * @export
 * @interface SsoEntities
 */
export interface SsoEntities {
    /**
     * 
     * @type {SsoUserScalarFieldEnum}
     * @memberof SsoEntities
     */
    'SsoUser': SsoUserScalarFieldEnum;
    /**
     * 
     * @type {SsoRefreshSessionScalarFieldEnum}
     * @memberof SsoEntities
     */
    'SsoRefreshSession': SsoRefreshSessionScalarFieldEnum;
    /**
     * 
     * @type {SsoEmailTemplateScalarFieldEnum}
     * @memberof SsoEntities
     */
    'SsoEmailTemplate': SsoEmailTemplateScalarFieldEnum;
    /**
     * 
     * @type {SsoOAuthProviderScalarFieldEnum}
     * @memberof SsoEntities
     */
    'SsoOAuthProvider': SsoOAuthProviderScalarFieldEnum;
    /**
     * 
     * @type {SsoOAuthProviderSettingsScalarFieldEnum}
     * @memberof SsoEntities
     */
    'SsoOAuthProviderSettings': SsoOAuthProviderSettingsScalarFieldEnum;
    /**
     * 
     * @type {SsoOAuthTokenScalarFieldEnum}
     * @memberof SsoEntities
     */
    'SsoOAuthToken': SsoOAuthTokenScalarFieldEnum;
    /**
     * 
     * @type {SsoTenantScalarFieldEnum}
     * @memberof SsoEntities
     */
    'SsoTenant': SsoTenantScalarFieldEnum;
    /**
     * 
     * @type {SsoRole}
     * @memberof SsoEntities
     */
    'role': SsoRole;
}


/**
 * 
 * @export
 * @interface SsoError
 */
export interface SsoError {
    /**
     * Sso error (SSO-000), User not found (SSO-001), Wrong password (SSO-002), User is exists (SSO-003), Wrong activate email code (SSO-004), Activate email not processed (SSO-005), Activate email processed (SSO-006), Refresh token not provided (SSO-007), Session expired (SSO-008), Invalid refresh session (SSO-009), Access token expired (SSO-010), User is exists (SSO-011), Email not verified (SSO-012), Forbidden (SSO-013), Wrong old password (SSO-014), Non-existent role specified (SSO-015), Bad access token (SSO-016), Your session has been blocked (SSO-017), Verification code not found (SSO-018)
     * @type {string}
     * @memberof SsoError
     */
    'message': string;
    /**
     * 
     * @type {SsoErrorEnum}
     * @memberof SsoError
     */
    'code': SsoErrorEnum;
    /**
     * 
     * @type {object}
     * @memberof SsoError
     */
    'metadata'?: object;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const SsoErrorEnum = {
    Sso000: 'SSO-000',
    Sso001: 'SSO-001',
    Sso002: 'SSO-002',
    Sso003: 'SSO-003',
    Sso004: 'SSO-004',
    Sso005: 'SSO-005',
    Sso006: 'SSO-006',
    Sso007: 'SSO-007',
    Sso008: 'SSO-008',
    Sso009: 'SSO-009',
    Sso010: 'SSO-010',
    Sso011: 'SSO-011',
    Sso012: 'SSO-012',
    Sso013: 'SSO-013',
    Sso014: 'SSO-014',
    Sso015: 'SSO-015',
    Sso016: 'SSO-016',
    Sso017: 'SSO-017',
    Sso018: 'SSO-018'
} as const;

export type SsoErrorEnum = typeof SsoErrorEnum[keyof typeof SsoErrorEnum];


/**
 * 
 * @export
 * @interface SsoOAuthProvider
 */
export interface SsoOAuthProvider {
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthProvider
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthProvider
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof SsoOAuthProvider
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthProvider
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthProvider
     */
    'updatedAt': string;
    /**
     * 
     * @type {Array<SsoOAuthProviderSettings>}
     * @memberof SsoOAuthProvider
     */
    'SsoOAuthProviderSettings'?: Array<SsoOAuthProviderSettings>;
    /**
     * 
     * @type {Array<SsoOAuthToken>}
     * @memberof SsoOAuthProvider
     */
    'SsoOAuthToken'?: Array<SsoOAuthToken>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SsoOAuthProviderScalarFieldEnum = {
    Id: 'id',
    Name: 'name',
    Enabled: 'enabled',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;

export type SsoOAuthProviderScalarFieldEnum = typeof SsoOAuthProviderScalarFieldEnum[keyof typeof SsoOAuthProviderScalarFieldEnum];


/**
 * 
 * @export
 * @interface SsoOAuthProviderSettings
 */
export interface SsoOAuthProviderSettings {
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthProviderSettings
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthProviderSettings
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthProviderSettings
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthProviderSettings
     */
    'providerId': string;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthProviderSettings
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthProviderSettings
     */
    'updatedAt': string;
    /**
     * 
     * @type {SsoOAuthProvider}
     * @memberof SsoOAuthProviderSettings
     */
    'SsoOAuthProvider'?: SsoOAuthProvider;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SsoOAuthProviderSettingsScalarFieldEnum = {
    Id: 'id',
    Name: 'name',
    Value: 'value',
    ProviderId: 'providerId',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;

export type SsoOAuthProviderSettingsScalarFieldEnum = typeof SsoOAuthProviderSettingsScalarFieldEnum[keyof typeof SsoOAuthProviderSettingsScalarFieldEnum];


/**
 * 
 * @export
 * @interface SsoOAuthToken
 */
export interface SsoOAuthToken {
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthToken
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthToken
     */
    'grantedAt': string;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthToken
     */
    'expiresAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthToken
     */
    'tokenType': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthToken
     */
    'scope': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthToken
     */
    'verificationCode': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthToken
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthToken
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthToken
     */
    'providerId': string;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthToken
     */
    'providerUserId': string;
    /**
     * 
     * @type {object}
     * @memberof SsoOAuthToken
     */
    'providerUserData': object | null;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthToken
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthToken
     */
    'updatedAt': string;
    /**
     * 
     * @type {SsoOAuthProvider}
     * @memberof SsoOAuthToken
     */
    'SsoOAuthProvider'?: SsoOAuthProvider;
    /**
     * 
     * @type {SsoTenant}
     * @memberof SsoOAuthToken
     */
    'SsoTenant'?: SsoTenant;
    /**
     * 
     * @type {SsoUser}
     * @memberof SsoOAuthToken
     */
    'SsoUser'?: SsoUser;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SsoOAuthTokenScalarFieldEnum = {
    Id: 'id',
    GrantedAt: 'grantedAt',
    AccessToken: 'accessToken',
    RefreshToken: 'refreshToken',
    ExpiresAt: 'expiresAt',
    TokenType: 'tokenType',
    Scope: 'scope',
    VerificationCode: 'verificationCode',
    UserId: 'userId',
    TenantId: 'tenantId',
    ProviderId: 'providerId',
    ProviderUserId: 'providerUserId',
    ProviderUserData: 'providerUserData',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;

export type SsoOAuthTokenScalarFieldEnum = typeof SsoOAuthTokenScalarFieldEnum[keyof typeof SsoOAuthTokenScalarFieldEnum];


/**
 * 
 * @export
 * @interface SsoOAuthVerificationArgs
 */
export interface SsoOAuthVerificationArgs {
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthVerificationArgs
     */
    'verificationCode': string;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthVerificationArgs
     */
    'fingerprint': string;
}
/**
 * 
 * @export
 * @interface SsoPublicTenantDto
 */
export interface SsoPublicTenantDto {
    /**
     * 
     * @type {string}
     * @memberof SsoPublicTenantDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SsoPublicTenantDto
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof SsoPublicTenantDto
     */
    'name': string;
    /**
     * 
     * @type {object}
     * @memberof SsoPublicTenantDto
     */
    'nameLocale': object | null;
    /**
     * 
     * @type {string}
     * @memberof SsoPublicTenantDto
     */
    'clientId': string;
    /**
     * 
     * @type {boolean}
     * @memberof SsoPublicTenantDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof SsoPublicTenantDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SsoPublicTenantDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface SsoRefreshSession
 */
export interface SsoRefreshSession {
    /**
     * 
     * @type {string}
     * @memberof SsoRefreshSession
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SsoRefreshSession
     */
    'userAgent': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoRefreshSession
     */
    'userIp': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoRefreshSession
     */
    'expiresAt': string | null;
    /**
     * 
     * @type {object}
     * @memberof SsoRefreshSession
     */
    'userData': object | null;
    /**
     * 
     * @type {boolean}
     * @memberof SsoRefreshSession
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof SsoRefreshSession
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof SsoRefreshSession
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof SsoRefreshSession
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SsoRefreshSession
     */
    'updatedAt': string;
    /**
     * 
     * @type {SsoTenant}
     * @memberof SsoRefreshSession
     */
    'SsoTenant'?: SsoTenant;
    /**
     * 
     * @type {SsoUser}
     * @memberof SsoRefreshSession
     */
    'SsoUser'?: SsoUser;
}
/**
 * 
 * @export
 * @interface SsoRefreshSessionDto
 */
export interface SsoRefreshSessionDto {
    /**
     * 
     * @type {string}
     * @memberof SsoRefreshSessionDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SsoRefreshSessionDto
     */
    'userAgent': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoRefreshSessionDto
     */
    'userIp': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoRefreshSessionDto
     */
    'expiresAt': string | null;
    /**
     * 
     * @type {object}
     * @memberof SsoRefreshSessionDto
     */
    'userData': object | null;
    /**
     * 
     * @type {boolean}
     * @memberof SsoRefreshSessionDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof SsoRefreshSessionDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SsoRefreshSessionDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SsoRefreshSessionScalarFieldEnum = {
    Id: 'id',
    RefreshToken: 'refreshToken',
    UserAgent: 'userAgent',
    Fingerprint: 'fingerprint',
    UserIp: 'userIp',
    ExpiresAt: 'expiresAt',
    UserData: 'userData',
    Enabled: 'enabled',
    UserId: 'userId',
    TenantId: 'tenantId',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;

export type SsoRefreshSessionScalarFieldEnum = typeof SsoRefreshSessionScalarFieldEnum[keyof typeof SsoRefreshSessionScalarFieldEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const SsoRole = {
    Admin: 'admin',
    Manager: 'manager',
    User: 'user'
} as const;

export type SsoRole = typeof SsoRole[keyof typeof SsoRole];


/**
 * 
 * @export
 * @interface SsoTenant
 */
export interface SsoTenant {
    /**
     * 
     * @type {string}
     * @memberof SsoTenant
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SsoTenant
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof SsoTenant
     */
    'name': string;
    /**
     * 
     * @type {object}
     * @memberof SsoTenant
     */
    'nameLocale': object | null;
    /**
     * 
     * @type {string}
     * @memberof SsoTenant
     */
    'clientId': string;
    /**
     * 
     * @type {string}
     * @memberof SsoTenant
     */
    'clientSecret': string;
    /**
     * 
     * @type {boolean}
     * @memberof SsoTenant
     */
    'enabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SsoTenant
     */
    'public': boolean;
    /**
     * 
     * @type {string}
     * @memberof SsoTenant
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SsoTenant
     */
    'updatedAt': string;
    /**
     * 
     * @type {Array<SsoEmailTemplate>}
     * @memberof SsoTenant
     */
    'SsoEmailTemplate'?: Array<SsoEmailTemplate>;
    /**
     * 
     * @type {Array<SsoOAuthToken>}
     * @memberof SsoTenant
     */
    'SsoOAuthToken'?: Array<SsoOAuthToken>;
    /**
     * 
     * @type {Array<SsoRefreshSession>}
     * @memberof SsoTenant
     */
    'SsoRefreshSession'?: Array<SsoRefreshSession>;
    /**
     * 
     * @type {Array<SsoUser>}
     * @memberof SsoTenant
     */
    'SsoUser'?: Array<SsoUser>;
}
/**
 * 
 * @export
 * @interface SsoTenantDto
 */
export interface SsoTenantDto {
    /**
     * 
     * @type {string}
     * @memberof SsoTenantDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SsoTenantDto
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof SsoTenantDto
     */
    'name': string;
    /**
     * 
     * @type {object}
     * @memberof SsoTenantDto
     */
    'nameLocale': object | null;
    /**
     * 
     * @type {string}
     * @memberof SsoTenantDto
     */
    'clientId': string;
    /**
     * 
     * @type {string}
     * @memberof SsoTenantDto
     */
    'clientSecret': string;
    /**
     * 
     * @type {boolean}
     * @memberof SsoTenantDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SsoTenantDto
     */
    'public': boolean;
    /**
     * 
     * @type {string}
     * @memberof SsoTenantDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SsoTenantDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SsoTenantScalarFieldEnum = {
    Id: 'id',
    Slug: 'slug',
    Name: 'name',
    NameLocale: 'nameLocale',
    ClientId: 'clientId',
    ClientSecret: 'clientSecret',
    Enabled: 'enabled',
    Public: 'public',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;

export type SsoTenantScalarFieldEnum = typeof SsoTenantScalarFieldEnum[keyof typeof SsoTenantScalarFieldEnum];


/**
 * 
 * @export
 * @interface SsoUser
 */
export interface SsoUser {
    /**
     * 
     * @type {string}
     * @memberof SsoUser
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SsoUser
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SsoUser
     */
    'phone': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUser
     */
    'username': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUser
     */
    'roles': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUser
     */
    'firstname': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUser
     */
    'lastname': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUser
     */
    'gender': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUser
     */
    'birthdate': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUser
     */
    'picture': string | null;
    /**
     * 
     * @type {object}
     * @memberof SsoUser
     */
    'appData': object | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUser
     */
    'revokedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUser
     */
    'emailVerifiedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUser
     */
    'phoneVerifiedAt': string | null;
    /**
     * 
     * @type {number}
     * @memberof SsoUser
     */
    'timezone': number | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUser
     */
    'lang': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUser
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof SsoUser
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SsoUser
     */
    'updatedAt': string;
    /**
     * 
     * @type {Array<SsoOAuthToken>}
     * @memberof SsoUser
     */
    'SsoOAuthToken'?: Array<SsoOAuthToken>;
    /**
     * 
     * @type {Array<SsoRefreshSession>}
     * @memberof SsoUser
     */
    'SsoRefreshSession'?: Array<SsoRefreshSession>;
    /**
     * 
     * @type {SsoTenant}
     * @memberof SsoUser
     */
    'SsoTenant'?: SsoTenant;
}
/**
 * 
 * @export
 * @interface SsoUserDto
 */
export interface SsoUserDto {
    /**
     * 
     * @type {string}
     * @memberof SsoUserDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SsoUserDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SsoUserDto
     */
    'phone': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUserDto
     */
    'username': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUserDto
     */
    'roles': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUserDto
     */
    'firstname': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUserDto
     */
    'lastname': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUserDto
     */
    'gender': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUserDto
     */
    'birthdate': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUserDto
     */
    'picture': string | null;
    /**
     * 
     * @type {object}
     * @memberof SsoUserDto
     */
    'appData': object | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUserDto
     */
    'revokedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUserDto
     */
    'emailVerifiedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUserDto
     */
    'phoneVerifiedAt': string | null;
    /**
     * 
     * @type {number}
     * @memberof SsoUserDto
     */
    'timezone': number | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUserDto
     */
    'lang': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUserDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SsoUserDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SsoUserScalarFieldEnum = {
    Id: 'id',
    Email: 'email',
    Phone: 'phone',
    Username: 'username',
    Password: 'password',
    Roles: 'roles',
    Firstname: 'firstname',
    Lastname: 'lastname',
    Gender: 'gender',
    Birthdate: 'birthdate',
    Picture: 'picture',
    AppData: 'appData',
    RevokedAt: 'revokedAt',
    EmailVerifiedAt: 'emailVerifiedAt',
    PhoneVerifiedAt: 'phoneVerifiedAt',
    Timezone: 'timezone',
    Lang: 'lang',
    TenantId: 'tenantId',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;

export type SsoUserScalarFieldEnum = typeof SsoUserScalarFieldEnum[keyof typeof SsoUserScalarFieldEnum];


/**
 * 
 * @export
 * @interface StatusResponse
 */
export interface StatusResponse {
    /**
     * 
     * @type {string}
     * @memberof StatusResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface TerminusHealthCheckControllerCheck200Response
 */
export interface TerminusHealthCheckControllerCheck200Response {
    /**
     * 
     * @type {string}
     * @memberof TerminusHealthCheckControllerCheck200Response
     */
    'status'?: string;
    /**
     * 
     * @type {{ [key: string]: TerminusHealthCheckControllerCheck200ResponseInfoValue; }}
     * @memberof TerminusHealthCheckControllerCheck200Response
     */
    'info'?: { [key: string]: TerminusHealthCheckControllerCheck200ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: TerminusHealthCheckControllerCheck200ResponseInfoValue; }}
     * @memberof TerminusHealthCheckControllerCheck200Response
     */
    'error'?: { [key: string]: TerminusHealthCheckControllerCheck200ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: TerminusHealthCheckControllerCheck200ResponseInfoValue; }}
     * @memberof TerminusHealthCheckControllerCheck200Response
     */
    'details'?: { [key: string]: TerminusHealthCheckControllerCheck200ResponseInfoValue; };
}
/**
 * 
 * @export
 * @interface TerminusHealthCheckControllerCheck200ResponseInfoValue
 */
export interface TerminusHealthCheckControllerCheck200ResponseInfoValue {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof TerminusHealthCheckControllerCheck200ResponseInfoValue
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface TerminusHealthCheckControllerCheck503Response
 */
export interface TerminusHealthCheckControllerCheck503Response {
    /**
     * 
     * @type {string}
     * @memberof TerminusHealthCheckControllerCheck503Response
     */
    'status'?: string;
    /**
     * 
     * @type {{ [key: string]: TerminusHealthCheckControllerCheck200ResponseInfoValue; }}
     * @memberof TerminusHealthCheckControllerCheck503Response
     */
    'info'?: { [key: string]: TerminusHealthCheckControllerCheck200ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: TerminusHealthCheckControllerCheck200ResponseInfoValue; }}
     * @memberof TerminusHealthCheckControllerCheck503Response
     */
    'error'?: { [key: string]: TerminusHealthCheckControllerCheck200ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: TerminusHealthCheckControllerCheck200ResponseInfoValue; }}
     * @memberof TerminusHealthCheckControllerCheck503Response
     */
    'details'?: { [key: string]: TerminusHealthCheckControllerCheck200ResponseInfoValue; };
}
/**
 * 
 * @export
 * @interface TokensResponse
 */
export interface TokensResponse {
    /**
     * 
     * @type {string}
     * @memberof TokensResponse
     */
    'accessToken': string;
    /**
     * 
     * @type {string}
     * @memberof TokensResponse
     */
    'refreshToken': string;
    /**
     * 
     * @type {SsoUser}
     * @memberof TokensResponse
     */
    'user': SsoUser;
}
/**
 * 
 * @export
 * @interface UpdateMetricsGithubMetricDto
 */
export interface UpdateMetricsGithubMetricDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateMetricsGithubMetricDto
     */
    'metricName'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateMetricsGithubMetricDto
     */
    'metricValue'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateMetricsGithubMetricDto
     */
    'recordedAt'?: string;
}
/**
 * 
 * @export
 * @interface UpdateMetricsGithubRepositoryDto
 */
export interface UpdateMetricsGithubRepositoryDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateMetricsGithubRepositoryDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMetricsGithubRepositoryDto
     */
    'owner'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateMetricsGithubRepositoryDto
     */
    'private'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateMetricsGithubRepositoryDto
     */
    'fork'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateMetricsGithubRepositoryDto
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateMetricsGithubRepositoryDto
     */
    'url'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateMetricsGithubRepositoryStatisticsDto
 */
export interface UpdateMetricsGithubRepositoryStatisticsDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateMetricsGithubRepositoryStatisticsDto
     */
    'periodType'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateMetricsGithubRepositoryStatisticsDto
     */
    'starsCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateMetricsGithubRepositoryStatisticsDto
     */
    'forksCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateMetricsGithubRepositoryStatisticsDto
     */
    'contributorsCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateMetricsGithubRepositoryStatisticsDto
     */
    'commitsCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateMetricsGithubRepositoryStatisticsDto
     */
    'lastCommitDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateMetricsGithubRepositoryStatisticsDto
     */
    'recordedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMetricsGithubRepositoryStatisticsDto
     */
    'tenantId'?: string;
}
/**
 * 
 * @export
 * @interface UpdateMetricsGithubTeamDto
 */
export interface UpdateMetricsGithubTeamDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateMetricsGithubTeamDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMetricsGithubTeamDto
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateMetricsGithubTeamDto
     */
    'tenantId'?: string;
}
/**
 * 
 * @export
 * @interface UpdateMetricsGithubTeamRepositoryDto
 */
export interface UpdateMetricsGithubTeamRepositoryDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateMetricsGithubTeamRepositoryDto
     */
    'tenantId'?: string;
}
/**
 * 
 * @export
 * @interface UpdateMetricsGithubTeamUserDto
 */
export interface UpdateMetricsGithubTeamUserDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateMetricsGithubTeamUserDto
     */
    'role'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateMetricsGithubTeamUserDto
     */
    'tenantId'?: string;
}
/**
 * 
 * @export
 * @interface UpdateMetricsGithubUserDto
 */
export interface UpdateMetricsGithubUserDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateMetricsGithubUserDto
     */
    'login'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMetricsGithubUserDto
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateMetricsGithubUserDto
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateMetricsGithubUserDto
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateMetricsGithubUserDto
     */
    'avatarUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateMetricsGithubUserDto
     */
    'websiteUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateMetricsGithubUserDto
     */
    'location'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateMetricsGithubUserDto
     */
    'telegramUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateMetricsGithubUserDto
     */
    'twitterUrl'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateMetricsGithubUserRepositoryDto
 */
export interface UpdateMetricsGithubUserRepositoryDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateMetricsGithubUserRepositoryDto
     */
    'role'?: string;
}
/**
 * 
 * @export
 * @interface UpdateMetricsGithubUserStatisticsDto
 */
export interface UpdateMetricsGithubUserStatisticsDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateMetricsGithubUserStatisticsDto
     */
    'periodType'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateMetricsGithubUserStatisticsDto
     */
    'followersCount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateMetricsGithubUserStatisticsDto
     */
    'followingCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateMetricsGithubUserStatisticsDto
     */
    'recordedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMetricsGithubUserStatisticsDto
     */
    'tenantId'?: string;
}
/**
 * 
 * @export
 * @interface UpdateMetricsUserDto
 */
export interface UpdateMetricsUserDto {
    /**
     * 
     * @type {MetricsRole}
     * @memberof UpdateMetricsUserDto
     */
    'userRole'?: MetricsRole;
}


/**
 * 
 * @export
 * @interface UpdateNotificationsEventDto
 */
export interface UpdateNotificationsEventDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationsEventDto
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationsEventDto
     */
    'operationName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationsEventDto
     */
    'subject'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationsEventDto
     */
    'html'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationsEventDto
     */
    'text'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateNotificationsEventDto
     */
    'attempt'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateNotificationsEventDto
     */
    'used'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof UpdateNotificationsEventDto
     */
    'error'?: object | null;
    /**
     * 
     * @type {object}
     * @memberof UpdateNotificationsEventDto
     */
    'senderData'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationsEventDto
     */
    'recipientGroupId'?: string;
    /**
     * 
     * @type {object}
     * @memberof UpdateNotificationsEventDto
     */
    'recipientData'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationsEventDto
     */
    'externalTenantId'?: string;
}
/**
 * 
 * @export
 * @interface UpdateProfileArgs
 */
export interface UpdateProfileArgs {
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileArgs
     */
    'firstname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileArgs
     */
    'lastname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileArgs
     */
    'gender'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileArgs
     */
    'birthdate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileArgs
     */
    'picture'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateProfileArgs
     */
    'timezone'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileArgs
     */
    'lang'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileArgs
     */
    'oldPassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileArgs
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileArgs
     */
    'confirmPassword'?: string;
}
/**
 * 
 * @export
 * @interface UpdateSsoEmailTemplateDto
 */
export interface UpdateSsoEmailTemplateDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoEmailTemplateDto
     */
    'subject'?: string;
    /**
     * 
     * @type {object}
     * @memberof UpdateSsoEmailTemplateDto
     */
    'subjectLocale'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoEmailTemplateDto
     */
    'text'?: string;
    /**
     * 
     * @type {object}
     * @memberof UpdateSsoEmailTemplateDto
     */
    'textLocale'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoEmailTemplateDto
     */
    'html'?: string;
    /**
     * 
     * @type {object}
     * @memberof UpdateSsoEmailTemplateDto
     */
    'htmlLocale'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoEmailTemplateDto
     */
    'operationName'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateSsoRefreshSessionDto
 */
export interface UpdateSsoRefreshSessionDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoRefreshSessionDto
     */
    'refreshToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoRefreshSessionDto
     */
    'userAgent'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoRefreshSessionDto
     */
    'fingerprint'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoRefreshSessionDto
     */
    'userIp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoRefreshSessionDto
     */
    'expiresAt'?: string | null;
    /**
     * 
     * @type {object}
     * @memberof UpdateSsoRefreshSessionDto
     */
    'userData'?: object | null;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateSsoRefreshSessionDto
     */
    'enabled'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateSsoTenantDto
 */
export interface UpdateSsoTenantDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoTenantDto
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoTenantDto
     */
    'name'?: string;
    /**
     * 
     * @type {object}
     * @memberof UpdateSsoTenantDto
     */
    'nameLocale'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoTenantDto
     */
    'clientId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoTenantDto
     */
    'clientSecret'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateSsoTenantDto
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateSsoTenantDto
     */
    'public'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateSsoUserDto
 */
export interface UpdateSsoUserDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoUserDto
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoUserDto
     */
    'phone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoUserDto
     */
    'username'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoUserDto
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoUserDto
     */
    'roles'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoUserDto
     */
    'firstname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoUserDto
     */
    'lastname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoUserDto
     */
    'gender'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoUserDto
     */
    'birthdate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoUserDto
     */
    'picture'?: string | null;
    /**
     * 
     * @type {object}
     * @memberof UpdateSsoUserDto
     */
    'appData'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoUserDto
     */
    'revokedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoUserDto
     */
    'emailVerifiedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoUserDto
     */
    'phoneVerifiedAt'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateSsoUserDto
     */
    'timezone'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoUserDto
     */
    'lang'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateWebhookDto
 */
export interface UpdateWebhookDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateWebhookDto
     */
    'eventName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWebhookDto
     */
    'endpoint'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateWebhookDto
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof UpdateWebhookDto
     */
    'headers'?: object | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateWebhookDto
     */
    'requestTimeout'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateWebhookDto
     */
    'workUntilDate'?: string | null;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * Validation error (VALIDATION-000)
     * @type {string}
     * @memberof ValidationError
     */
    'message': string;
    /**
     * 
     * @type {ValidationErrorEnum}
     * @memberof ValidationError
     */
    'code': ValidationErrorEnum;
    /**
     * 
     * @type {Array<ValidationErrorMetadata>}
     * @memberof ValidationError
     */
    'metadata'?: Array<ValidationErrorMetadata>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ValidationErrorEnum = {
    Validation000: 'VALIDATION-000'
} as const;

export type ValidationErrorEnum = typeof ValidationErrorEnum[keyof typeof ValidationErrorEnum];


/**
 * 
 * @export
 * @interface ValidationErrorMetadata
 */
export interface ValidationErrorMetadata {
    /**
     * 
     * @type {string}
     * @memberof ValidationErrorMetadata
     */
    'property': string;
    /**
     * 
     * @type {Array<ValidationErrorMetadataConstraint>}
     * @memberof ValidationErrorMetadata
     */
    'constraints': Array<ValidationErrorMetadataConstraint>;
    /**
     * 
     * @type {Array<ValidationErrorMetadata>}
     * @memberof ValidationErrorMetadata
     */
    'children'?: Array<ValidationErrorMetadata>;
}
/**
 * 
 * @export
 * @interface ValidationErrorMetadataConstraint
 */
export interface ValidationErrorMetadataConstraint {
    /**
     * 
     * @type {string}
     * @memberof ValidationErrorMetadataConstraint
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationErrorMetadataConstraint
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface Webhook
 */
export interface Webhook {
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'eventName': string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'endpoint': string;
    /**
     * 
     * @type {boolean}
     * @memberof Webhook
     */
    'enabled': boolean;
    /**
     * 
     * @type {object}
     * @memberof Webhook
     */
    'headers': object | null;
    /**
     * 
     * @type {number}
     * @memberof Webhook
     */
    'requestTimeout': number | null;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'externalTenantId': string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'createdBy': string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'updatedBy': string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'workUntilDate': string | null;
    /**
     * 
     * @type {WebhookUser}
     * @memberof Webhook
     */
    'WebhookUser_Webhook_createdByToWebhookUser'?: WebhookUser;
    /**
     * 
     * @type {WebhookUser}
     * @memberof Webhook
     */
    'WebhookUser_Webhook_updatedByToWebhookUser'?: WebhookUser;
    /**
     * 
     * @type {Array<WebhookLog>}
     * @memberof Webhook
     */
    'WebhookLog'?: Array<WebhookLog>;
}
/**
 * 
 * @export
 * @interface WebhookEntities
 */
export interface WebhookEntities {
    /**
     * 
     * @type {WebhookScalarFieldEnum}
     * @memberof WebhookEntities
     */
    'Webhook': WebhookScalarFieldEnum;
    /**
     * 
     * @type {WebhookLogScalarFieldEnum}
     * @memberof WebhookEntities
     */
    'WebhookLog': WebhookLogScalarFieldEnum;
    /**
     * 
     * @type {WebhookUserScalarFieldEnum}
     * @memberof WebhookEntities
     */
    'WebhookUser': WebhookUserScalarFieldEnum;
}


/**
 * 
 * @export
 * @interface WebhookError
 */
export interface WebhookError {
    /**
     * Webhook error (WEBHOOK-000), Tenant ID not set (WEBHOOK-003), User ID not set (WEBHOOK-002), Forbidden (WEBHOOK-001), User not found (WEBHOOK-004), Event not found (WEBHOOK-005)
     * @type {string}
     * @memberof WebhookError
     */
    'message': string;
    /**
     * 
     * @type {WebhookErrorEnum}
     * @memberof WebhookError
     */
    'code': WebhookErrorEnum;
    /**
     * 
     * @type {object}
     * @memberof WebhookError
     */
    'metadata'?: object;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const WebhookErrorEnum = {
    Webhook000: 'WEBHOOK-000',
    Webhook001: 'WEBHOOK-001',
    Webhook002: 'WEBHOOK-002',
    Webhook003: 'WEBHOOK-003',
    Webhook004: 'WEBHOOK-004',
    Webhook005: 'WEBHOOK-005'
} as const;

export type WebhookErrorEnum = typeof WebhookErrorEnum[keyof typeof WebhookErrorEnum];


/**
 * 
 * @export
 * @interface WebhookEvent
 */
export interface WebhookEvent {
    /**
     * 
     * @type {string}
     * @memberof WebhookEvent
     */
    'eventName': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookEvent
     */
    'description': string;
    /**
     * 
     * @type {object}
     * @memberof WebhookEvent
     */
    'example': object;
}
/**
 * 
 * @export
 * @interface WebhookLog
 */
export interface WebhookLog {
    /**
     * 
     * @type {string}
     * @memberof WebhookLog
     */
    'id': string;
    /**
     * 
     * @type {object}
     * @memberof WebhookLog
     */
    'request': object;
    /**
     * 
     * @type {string}
     * @memberof WebhookLog
     */
    'responseStatus': string;
    /**
     * 
     * @type {object}
     * @memberof WebhookLog
     */
    'response': object | null;
    /**
     * 
     * @type {WebhookStatus}
     * @memberof WebhookLog
     */
    'webhookStatus': WebhookStatus;
    /**
     * 
     * @type {string}
     * @memberof WebhookLog
     */
    'webhookId': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookLog
     */
    'externalTenantId': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookLog
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookLog
     */
    'updatedAt': string;
    /**
     * 
     * @type {Webhook}
     * @memberof WebhookLog
     */
    'Webhook'?: Webhook;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const WebhookLogScalarFieldEnum = {
    Id: 'id',
    Request: 'request',
    ResponseStatus: 'responseStatus',
    Response: 'response',
    WebhookStatus: 'webhookStatus',
    WebhookId: 'webhookId',
    ExternalTenantId: 'externalTenantId',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;

export type WebhookLogScalarFieldEnum = typeof WebhookLogScalarFieldEnum[keyof typeof WebhookLogScalarFieldEnum];


/**
 * 
 * @export
 * @interface WebhookLogsControllerFindManyLogs400Response
 */
export interface WebhookLogsControllerFindManyLogs400Response {
    /**
     * Validation error (VALIDATION-000)
     * @type {string}
     * @memberof WebhookLogsControllerFindManyLogs400Response
     */
    'message': string;
    /**
     * 
     * @type {ValidationErrorEnum}
     * @memberof WebhookLogsControllerFindManyLogs400Response
     */
    'code': ValidationErrorEnum;
    /**
     * 
     * @type {Array<ValidationErrorMetadata>}
     * @memberof WebhookLogsControllerFindManyLogs400Response
     */
    'metadata'?: Array<ValidationErrorMetadata>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const WebhookRole = {
    Admin: 'Admin',
    User: 'User'
} as const;

export type WebhookRole = typeof WebhookRole[keyof typeof WebhookRole];


/**
 * 
 * @export
 * @enum {string}
 */

export const WebhookScalarFieldEnum = {
    Id: 'id',
    EventName: 'eventName',
    Endpoint: 'endpoint',
    Enabled: 'enabled',
    Headers: 'headers',
    RequestTimeout: 'requestTimeout',
    ExternalTenantId: 'externalTenantId',
    CreatedBy: 'createdBy',
    UpdatedBy: 'updatedBy',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt',
    WorkUntilDate: 'workUntilDate'
} as const;

export type WebhookScalarFieldEnum = typeof WebhookScalarFieldEnum[keyof typeof WebhookScalarFieldEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const WebhookStatus = {
    Pending: 'Pending',
    Process: 'Process',
    Success: 'Success',
    Error: 'Error',
    Timeout: 'Timeout'
} as const;

export type WebhookStatus = typeof WebhookStatus[keyof typeof WebhookStatus];


/**
 * 
 * @export
 * @interface WebhookTestRequestResponse
 */
export interface WebhookTestRequestResponse {
    /**
     * 
     * @type {object}
     * @memberof WebhookTestRequestResponse
     */
    'request': object;
    /**
     * 
     * @type {string}
     * @memberof WebhookTestRequestResponse
     */
    'responseStatus': string;
    /**
     * 
     * @type {object}
     * @memberof WebhookTestRequestResponse
     */
    'response': object | null;
    /**
     * 
     * @type {WebhookStatus}
     * @memberof WebhookTestRequestResponse
     */
    'webhookStatus': WebhookStatus;
}


/**
 * 
 * @export
 * @interface WebhookUser
 */
export interface WebhookUser {
    /**
     * 
     * @type {string}
     * @memberof WebhookUser
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookUser
     */
    'externalTenantId': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookUser
     */
    'externalUserId': string;
    /**
     * 
     * @type {WebhookRole}
     * @memberof WebhookUser
     */
    'userRole': WebhookRole;
    /**
     * 
     * @type {string}
     * @memberof WebhookUser
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookUser
     */
    'updatedAt': string;
    /**
     * 
     * @type {Array<Webhook>}
     * @memberof WebhookUser
     */
    'Webhook_Webhook_createdByToWebhookUser'?: Array<Webhook>;
    /**
     * 
     * @type {Array<Webhook>}
     * @memberof WebhookUser
     */
    'Webhook_Webhook_updatedByToWebhookUser'?: Array<Webhook>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const WebhookUserScalarFieldEnum = {
    Id: 'id',
    ExternalTenantId: 'externalTenantId',
    ExternalUserId: 'externalUserId',
    UserRole: 'userRole',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;

export type WebhookUserScalarFieldEnum = typeof WebhookUserScalarFieldEnum[keyof typeof WebhookUserScalarFieldEnum];



/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} downloadUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesControllerDeleteFile: async (downloadUrl: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'downloadUrl' is not null or undefined
            assertParamExists('filesControllerDeleteFile', 'downloadUrl', downloadUrl)
            const localVarPath = `/api/files/delete-file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (downloadUrl !== undefined) {
                localVarQueryParameter['downloadUrl'] = downloadUrl;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} ext 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesControllerGetPresignedUrl: async (ext: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ext' is not null or undefined
            assertParamExists('filesControllerGetPresignedUrl', 'ext', ext)
            const localVarPath = `/api/files/get-presigned-url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ext !== undefined) {
                localVarQueryParameter['ext'] = ext;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} downloadUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesControllerDeleteFile(downloadUrl: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesControllerDeleteFile(downloadUrl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.filesControllerDeleteFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} ext 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesControllerGetPresignedUrl(ext: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilesPresignedUrls>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesControllerGetPresignedUrl(ext, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.filesControllerGetPresignedUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} downloadUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesControllerDeleteFile(downloadUrl: string, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.filesControllerDeleteFile(downloadUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} ext 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesControllerGetPresignedUrl(ext: string, options?: RawAxiosRequestConfig): AxiosPromise<FilesPresignedUrls> {
            return localVarFp.filesControllerGetPresignedUrl(ext, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     * 
     * @param {string} downloadUrl 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public filesControllerDeleteFile(downloadUrl: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).filesControllerDeleteFile(downloadUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} ext 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public filesControllerGetPresignedUrl(ext: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).filesControllerGetPresignedUrl(ext, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MetricsApi - axios parameter creator
 * @export
 */
export const MetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateFullMetricsGithubMetricDto} createFullMetricsGithubMetricDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubMetricControllerCreateOne: async (createFullMetricsGithubMetricDto: CreateFullMetricsGithubMetricDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createFullMetricsGithubMetricDto' is not null or undefined
            assertParamExists('metricsGithubMetricControllerCreateOne', 'createFullMetricsGithubMetricDto', createFullMetricsGithubMetricDto)
            const localVarPath = `/api/metrics/github/metric`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFullMetricsGithubMetricDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubMetricControllerDeleteOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metricsGithubMetricControllerDeleteOne', 'id', id)
            const localVarPath = `/api/metrics/github/metric/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubMetricControllerFindMany: async (curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/metrics/github/metric`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenantId'] = tenantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubMetricControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metricsGithubMetricControllerFindOne', 'id', id)
            const localVarPath = `/api/metrics/github/metric/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetricsGithubMetricDto} updateMetricsGithubMetricDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubMetricControllerUpdateOne: async (id: string, updateMetricsGithubMetricDto: UpdateMetricsGithubMetricDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metricsGithubMetricControllerUpdateOne', 'id', id)
            // verify required parameter 'updateMetricsGithubMetricDto' is not null or undefined
            assertParamExists('metricsGithubMetricControllerUpdateOne', 'updateMetricsGithubMetricDto', updateMetricsGithubMetricDto)
            const localVarPath = `/api/metrics/github/metric/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMetricsGithubMetricDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateMetricsGithubRepositoryDto} createMetricsGithubRepositoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubRepositoryControllerCreateOne: async (createMetricsGithubRepositoryDto: CreateMetricsGithubRepositoryDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createMetricsGithubRepositoryDto' is not null or undefined
            assertParamExists('metricsGithubRepositoryControllerCreateOne', 'createMetricsGithubRepositoryDto', createMetricsGithubRepositoryDto)
            const localVarPath = `/api/metrics/github/repository`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMetricsGithubRepositoryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubRepositoryControllerDeleteOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metricsGithubRepositoryControllerDeleteOne', 'id', id)
            const localVarPath = `/api/metrics/github/repository/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubRepositoryControllerFindMany: async (curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/metrics/github/repository`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenantId'] = tenantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubRepositoryControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metricsGithubRepositoryControllerFindOne', 'id', id)
            const localVarPath = `/api/metrics/github/repository/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetricsGithubRepositoryDto} updateMetricsGithubRepositoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubRepositoryControllerUpdateOne: async (id: string, updateMetricsGithubRepositoryDto: UpdateMetricsGithubRepositoryDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metricsGithubRepositoryControllerUpdateOne', 'id', id)
            // verify required parameter 'updateMetricsGithubRepositoryDto' is not null or undefined
            assertParamExists('metricsGithubRepositoryControllerUpdateOne', 'updateMetricsGithubRepositoryDto', updateMetricsGithubRepositoryDto)
            const localVarPath = `/api/metrics/github/repository/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMetricsGithubRepositoryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateFullMetricsGithubRepositoryStatisticsDto} createFullMetricsGithubRepositoryStatisticsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubRepositoryStatisticsControllerCreateOne: async (createFullMetricsGithubRepositoryStatisticsDto: CreateFullMetricsGithubRepositoryStatisticsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createFullMetricsGithubRepositoryStatisticsDto' is not null or undefined
            assertParamExists('metricsGithubRepositoryStatisticsControllerCreateOne', 'createFullMetricsGithubRepositoryStatisticsDto', createFullMetricsGithubRepositoryStatisticsDto)
            const localVarPath = `/api/metrics/github/repository/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFullMetricsGithubRepositoryStatisticsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubRepositoryStatisticsControllerDeleteOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metricsGithubRepositoryStatisticsControllerDeleteOne', 'id', id)
            const localVarPath = `/api/metrics/github/repository/statistics/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubRepositoryStatisticsControllerFindMany: async (curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/metrics/github/repository/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenantId'] = tenantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubRepositoryStatisticsControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metricsGithubRepositoryStatisticsControllerFindOne', 'id', id)
            const localVarPath = `/api/metrics/github/repository/statistics/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetricsGithubRepositoryStatisticsDto} updateMetricsGithubRepositoryStatisticsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubRepositoryStatisticsControllerUpdateOne: async (id: string, updateMetricsGithubRepositoryStatisticsDto: UpdateMetricsGithubRepositoryStatisticsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metricsGithubRepositoryStatisticsControllerUpdateOne', 'id', id)
            // verify required parameter 'updateMetricsGithubRepositoryStatisticsDto' is not null or undefined
            assertParamExists('metricsGithubRepositoryStatisticsControllerUpdateOne', 'updateMetricsGithubRepositoryStatisticsDto', updateMetricsGithubRepositoryStatisticsDto)
            const localVarPath = `/api/metrics/github/repository/statistics/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMetricsGithubRepositoryStatisticsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateMetricsGithubTeamDto} createMetricsGithubTeamDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubTeamControllerCreateOne: async (createMetricsGithubTeamDto: CreateMetricsGithubTeamDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createMetricsGithubTeamDto' is not null or undefined
            assertParamExists('metricsGithubTeamControllerCreateOne', 'createMetricsGithubTeamDto', createMetricsGithubTeamDto)
            const localVarPath = `/api/metrics/github/team`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMetricsGithubTeamDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubTeamControllerDeleteOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metricsGithubTeamControllerDeleteOne', 'id', id)
            const localVarPath = `/api/metrics/github/team/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubTeamControllerFindMany: async (curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/metrics/github/team`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenantId'] = tenantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubTeamControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metricsGithubTeamControllerFindOne', 'id', id)
            const localVarPath = `/api/metrics/github/team/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetricsGithubTeamDto} updateMetricsGithubTeamDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubTeamControllerUpdateOne: async (id: string, updateMetricsGithubTeamDto: UpdateMetricsGithubTeamDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metricsGithubTeamControllerUpdateOne', 'id', id)
            // verify required parameter 'updateMetricsGithubTeamDto' is not null or undefined
            assertParamExists('metricsGithubTeamControllerUpdateOne', 'updateMetricsGithubTeamDto', updateMetricsGithubTeamDto)
            const localVarPath = `/api/metrics/github/team/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMetricsGithubTeamDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateFullMetricsGithubTeamRepositoryDto} createFullMetricsGithubTeamRepositoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubTeamRepositoryControllerCreateOne: async (createFullMetricsGithubTeamRepositoryDto: CreateFullMetricsGithubTeamRepositoryDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createFullMetricsGithubTeamRepositoryDto' is not null or undefined
            assertParamExists('metricsGithubTeamRepositoryControllerCreateOne', 'createFullMetricsGithubTeamRepositoryDto', createFullMetricsGithubTeamRepositoryDto)
            const localVarPath = `/api/metrics/github/team/repository`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFullMetricsGithubTeamRepositoryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubTeamRepositoryControllerDeleteOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metricsGithubTeamRepositoryControllerDeleteOne', 'id', id)
            const localVarPath = `/api/metrics/github/team/repository/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubTeamRepositoryControllerFindMany: async (curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/metrics/github/team/repository`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenantId'] = tenantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubTeamRepositoryControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metricsGithubTeamRepositoryControllerFindOne', 'id', id)
            const localVarPath = `/api/metrics/github/team/repository/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetricsGithubTeamRepositoryDto} updateMetricsGithubTeamRepositoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubTeamRepositoryControllerUpdateOne: async (id: string, updateMetricsGithubTeamRepositoryDto: UpdateMetricsGithubTeamRepositoryDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metricsGithubTeamRepositoryControllerUpdateOne', 'id', id)
            // verify required parameter 'updateMetricsGithubTeamRepositoryDto' is not null or undefined
            assertParamExists('metricsGithubTeamRepositoryControllerUpdateOne', 'updateMetricsGithubTeamRepositoryDto', updateMetricsGithubTeamRepositoryDto)
            const localVarPath = `/api/metrics/github/team/repository/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMetricsGithubTeamRepositoryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateFullMetricsGithubTeamUserDto} createFullMetricsGithubTeamUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubTeamUserControllerCreateOne: async (createFullMetricsGithubTeamUserDto: CreateFullMetricsGithubTeamUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createFullMetricsGithubTeamUserDto' is not null or undefined
            assertParamExists('metricsGithubTeamUserControllerCreateOne', 'createFullMetricsGithubTeamUserDto', createFullMetricsGithubTeamUserDto)
            const localVarPath = `/api/metrics/github/team/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFullMetricsGithubTeamUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubTeamUserControllerDeleteOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metricsGithubTeamUserControllerDeleteOne', 'id', id)
            const localVarPath = `/api/metrics/github/team/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubTeamUserControllerFindMany: async (curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/metrics/github/team/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenantId'] = tenantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubTeamUserControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metricsGithubTeamUserControllerFindOne', 'id', id)
            const localVarPath = `/api/metrics/github/team/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetricsGithubTeamUserDto} updateMetricsGithubTeamUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubTeamUserControllerUpdateOne: async (id: string, updateMetricsGithubTeamUserDto: UpdateMetricsGithubTeamUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metricsGithubTeamUserControllerUpdateOne', 'id', id)
            // verify required parameter 'updateMetricsGithubTeamUserDto' is not null or undefined
            assertParamExists('metricsGithubTeamUserControllerUpdateOne', 'updateMetricsGithubTeamUserDto', updateMetricsGithubTeamUserDto)
            const localVarPath = `/api/metrics/github/team/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMetricsGithubTeamUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateMetricsGithubUserDto} createMetricsGithubUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubUserControllerCreateOne: async (createMetricsGithubUserDto: CreateMetricsGithubUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createMetricsGithubUserDto' is not null or undefined
            assertParamExists('metricsGithubUserControllerCreateOne', 'createMetricsGithubUserDto', createMetricsGithubUserDto)
            const localVarPath = `/api/metrics/github/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMetricsGithubUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubUserControllerDeleteOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metricsGithubUserControllerDeleteOne', 'id', id)
            const localVarPath = `/api/metrics/github/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubUserControllerFindMany: async (curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/metrics/github/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenantId'] = tenantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubUserControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metricsGithubUserControllerFindOne', 'id', id)
            const localVarPath = `/api/metrics/github/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetricsGithubUserDto} updateMetricsGithubUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubUserControllerUpdateOne: async (id: string, updateMetricsGithubUserDto: UpdateMetricsGithubUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metricsGithubUserControllerUpdateOne', 'id', id)
            // verify required parameter 'updateMetricsGithubUserDto' is not null or undefined
            assertParamExists('metricsGithubUserControllerUpdateOne', 'updateMetricsGithubUserDto', updateMetricsGithubUserDto)
            const localVarPath = `/api/metrics/github/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMetricsGithubUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateFullMetricsGithubUserRepositoryDto} createFullMetricsGithubUserRepositoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubUserRepositoryControllerCreateOne: async (createFullMetricsGithubUserRepositoryDto: CreateFullMetricsGithubUserRepositoryDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createFullMetricsGithubUserRepositoryDto' is not null or undefined
            assertParamExists('metricsGithubUserRepositoryControllerCreateOne', 'createFullMetricsGithubUserRepositoryDto', createFullMetricsGithubUserRepositoryDto)
            const localVarPath = `/api/metrics/github/user-repository`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFullMetricsGithubUserRepositoryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubUserRepositoryControllerDeleteOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metricsGithubUserRepositoryControllerDeleteOne', 'id', id)
            const localVarPath = `/api/metrics/github/user-repository/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubUserRepositoryControllerFindMany: async (curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/metrics/github/user-repository`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenantId'] = tenantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubUserRepositoryControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metricsGithubUserRepositoryControllerFindOne', 'id', id)
            const localVarPath = `/api/metrics/github/user-repository/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetricsGithubUserRepositoryDto} updateMetricsGithubUserRepositoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubUserRepositoryControllerUpdateOne: async (id: string, updateMetricsGithubUserRepositoryDto: UpdateMetricsGithubUserRepositoryDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metricsGithubUserRepositoryControllerUpdateOne', 'id', id)
            // verify required parameter 'updateMetricsGithubUserRepositoryDto' is not null or undefined
            assertParamExists('metricsGithubUserRepositoryControllerUpdateOne', 'updateMetricsGithubUserRepositoryDto', updateMetricsGithubUserRepositoryDto)
            const localVarPath = `/api/metrics/github/user-repository/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMetricsGithubUserRepositoryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateFullMetricsGithubUserStatisticsDto} createFullMetricsGithubUserStatisticsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubUserStatisticsControllerCreateOne: async (createFullMetricsGithubUserStatisticsDto: CreateFullMetricsGithubUserStatisticsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createFullMetricsGithubUserStatisticsDto' is not null or undefined
            assertParamExists('metricsGithubUserStatisticsControllerCreateOne', 'createFullMetricsGithubUserStatisticsDto', createFullMetricsGithubUserStatisticsDto)
            const localVarPath = `/api/metrics/github/user/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFullMetricsGithubUserStatisticsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubUserStatisticsControllerDeleteOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metricsGithubUserStatisticsControllerDeleteOne', 'id', id)
            const localVarPath = `/api/metrics/github/user/statistics/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubUserStatisticsControllerFindMany: async (curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/metrics/github/user/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenantId'] = tenantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubUserStatisticsControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metricsGithubUserStatisticsControllerFindOne', 'id', id)
            const localVarPath = `/api/metrics/github/user/statistics/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetricsGithubUserStatisticsDto} updateMetricsGithubUserStatisticsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubUserStatisticsControllerUpdateOne: async (id: string, updateMetricsGithubUserStatisticsDto: UpdateMetricsGithubUserStatisticsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metricsGithubUserStatisticsControllerUpdateOne', 'id', id)
            // verify required parameter 'updateMetricsGithubUserStatisticsDto' is not null or undefined
            assertParamExists('metricsGithubUserStatisticsControllerUpdateOne', 'updateMetricsGithubUserStatisticsDto', updateMetricsGithubUserStatisticsDto)
            const localVarPath = `/api/metrics/github/user/statistics/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMetricsGithubUserStatisticsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateFullMetricsUserDto} createFullMetricsUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsUserControllerCreateOne: async (createFullMetricsUserDto: CreateFullMetricsUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createFullMetricsUserDto' is not null or undefined
            assertParamExists('metricsUserControllerCreateOne', 'createFullMetricsUserDto', createFullMetricsUserDto)
            const localVarPath = `/api/metrics/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFullMetricsUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsUserControllerDeleteOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metricsUserControllerDeleteOne', 'id', id)
            const localVarPath = `/api/metrics/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsUserControllerFindMany: async (curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/metrics/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenantId'] = tenantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsUserControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metricsUserControllerFindOne', 'id', id)
            const localVarPath = `/api/metrics/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetricsUserDto} updateMetricsUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsUserControllerUpdateOne: async (id: string, updateMetricsUserDto: UpdateMetricsUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metricsUserControllerUpdateOne', 'id', id)
            // verify required parameter 'updateMetricsUserDto' is not null or undefined
            assertParamExists('metricsUserControllerUpdateOne', 'updateMetricsUserDto', updateMetricsUserDto)
            const localVarPath = `/api/metrics/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMetricsUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateFullMetricsGithubMetricDto} createFullMetricsGithubMetricDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubMetricControllerCreateOne(createFullMetricsGithubMetricDto: CreateFullMetricsGithubMetricDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsGithubMetricDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubMetricControllerCreateOne(createFullMetricsGithubMetricDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubMetricControllerCreateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubMetricControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubMetricControllerDeleteOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubMetricControllerDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubMetricControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManyMetricsGithubMetricResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubMetricControllerFindMany(curPage, perPage, searchText, sort, tenantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubMetricControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubMetricControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsGithubMetricDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubMetricControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubMetricControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetricsGithubMetricDto} updateMetricsGithubMetricDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubMetricControllerUpdateOne(id: string, updateMetricsGithubMetricDto: UpdateMetricsGithubMetricDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsGithubMetricDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubMetricControllerUpdateOne(id, updateMetricsGithubMetricDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubMetricControllerUpdateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateMetricsGithubRepositoryDto} createMetricsGithubRepositoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubRepositoryControllerCreateOne(createMetricsGithubRepositoryDto: CreateMetricsGithubRepositoryDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsGithubRepositoryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubRepositoryControllerCreateOne(createMetricsGithubRepositoryDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubRepositoryControllerCreateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubRepositoryControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubRepositoryControllerDeleteOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubRepositoryControllerDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubRepositoryControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManyMetricsGithubRepositoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubRepositoryControllerFindMany(curPage, perPage, searchText, sort, tenantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubRepositoryControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubRepositoryControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsGithubRepositoryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubRepositoryControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubRepositoryControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetricsGithubRepositoryDto} updateMetricsGithubRepositoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubRepositoryControllerUpdateOne(id: string, updateMetricsGithubRepositoryDto: UpdateMetricsGithubRepositoryDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsGithubRepositoryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubRepositoryControllerUpdateOne(id, updateMetricsGithubRepositoryDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubRepositoryControllerUpdateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateFullMetricsGithubRepositoryStatisticsDto} createFullMetricsGithubRepositoryStatisticsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubRepositoryStatisticsControllerCreateOne(createFullMetricsGithubRepositoryStatisticsDto: CreateFullMetricsGithubRepositoryStatisticsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsGithubRepositoryStatisticsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubRepositoryStatisticsControllerCreateOne(createFullMetricsGithubRepositoryStatisticsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubRepositoryStatisticsControllerCreateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubRepositoryStatisticsControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubRepositoryStatisticsControllerDeleteOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubRepositoryStatisticsControllerDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubRepositoryStatisticsControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManyMetricsGithubRepositoryStatisticsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubRepositoryStatisticsControllerFindMany(curPage, perPage, searchText, sort, tenantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubRepositoryStatisticsControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubRepositoryStatisticsControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsGithubRepositoryStatisticsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubRepositoryStatisticsControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubRepositoryStatisticsControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetricsGithubRepositoryStatisticsDto} updateMetricsGithubRepositoryStatisticsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubRepositoryStatisticsControllerUpdateOne(id: string, updateMetricsGithubRepositoryStatisticsDto: UpdateMetricsGithubRepositoryStatisticsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsGithubRepositoryStatisticsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubRepositoryStatisticsControllerUpdateOne(id, updateMetricsGithubRepositoryStatisticsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubRepositoryStatisticsControllerUpdateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateMetricsGithubTeamDto} createMetricsGithubTeamDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubTeamControllerCreateOne(createMetricsGithubTeamDto: CreateMetricsGithubTeamDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsGithubTeamDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubTeamControllerCreateOne(createMetricsGithubTeamDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubTeamControllerCreateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubTeamControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubTeamControllerDeleteOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubTeamControllerDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubTeamControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManyMetricsGithubTeamResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubTeamControllerFindMany(curPage, perPage, searchText, sort, tenantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubTeamControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubTeamControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsGithubTeamDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubTeamControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubTeamControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetricsGithubTeamDto} updateMetricsGithubTeamDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubTeamControllerUpdateOne(id: string, updateMetricsGithubTeamDto: UpdateMetricsGithubTeamDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsGithubTeamDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubTeamControllerUpdateOne(id, updateMetricsGithubTeamDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubTeamControllerUpdateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateFullMetricsGithubTeamRepositoryDto} createFullMetricsGithubTeamRepositoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubTeamRepositoryControllerCreateOne(createFullMetricsGithubTeamRepositoryDto: CreateFullMetricsGithubTeamRepositoryDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsGithubTeamRepositoryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubTeamRepositoryControllerCreateOne(createFullMetricsGithubTeamRepositoryDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubTeamRepositoryControllerCreateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubTeamRepositoryControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubTeamRepositoryControllerDeleteOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubTeamRepositoryControllerDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubTeamRepositoryControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManyMetricsGithubTeamRepositoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubTeamRepositoryControllerFindMany(curPage, perPage, searchText, sort, tenantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubTeamRepositoryControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubTeamRepositoryControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsGithubTeamRepositoryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubTeamRepositoryControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubTeamRepositoryControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetricsGithubTeamRepositoryDto} updateMetricsGithubTeamRepositoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubTeamRepositoryControllerUpdateOne(id: string, updateMetricsGithubTeamRepositoryDto: UpdateMetricsGithubTeamRepositoryDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsGithubTeamRepositoryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubTeamRepositoryControllerUpdateOne(id, updateMetricsGithubTeamRepositoryDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubTeamRepositoryControllerUpdateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateFullMetricsGithubTeamUserDto} createFullMetricsGithubTeamUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubTeamUserControllerCreateOne(createFullMetricsGithubTeamUserDto: CreateFullMetricsGithubTeamUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsGithubTeamUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubTeamUserControllerCreateOne(createFullMetricsGithubTeamUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubTeamUserControllerCreateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubTeamUserControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubTeamUserControllerDeleteOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubTeamUserControllerDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubTeamUserControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManyMetricsGithubTeamUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubTeamUserControllerFindMany(curPage, perPage, searchText, sort, tenantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubTeamUserControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubTeamUserControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsGithubTeamUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubTeamUserControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubTeamUserControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetricsGithubTeamUserDto} updateMetricsGithubTeamUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubTeamUserControllerUpdateOne(id: string, updateMetricsGithubTeamUserDto: UpdateMetricsGithubTeamUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsGithubTeamUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubTeamUserControllerUpdateOne(id, updateMetricsGithubTeamUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubTeamUserControllerUpdateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateMetricsGithubUserDto} createMetricsGithubUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubUserControllerCreateOne(createMetricsGithubUserDto: CreateMetricsGithubUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsGithubUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubUserControllerCreateOne(createMetricsGithubUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubUserControllerCreateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubUserControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubUserControllerDeleteOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubUserControllerDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubUserControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManyMetricsGithubUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubUserControllerFindMany(curPage, perPage, searchText, sort, tenantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubUserControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubUserControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsGithubUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubUserControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubUserControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetricsGithubUserDto} updateMetricsGithubUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubUserControllerUpdateOne(id: string, updateMetricsGithubUserDto: UpdateMetricsGithubUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsGithubUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubUserControllerUpdateOne(id, updateMetricsGithubUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubUserControllerUpdateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateFullMetricsGithubUserRepositoryDto} createFullMetricsGithubUserRepositoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubUserRepositoryControllerCreateOne(createFullMetricsGithubUserRepositoryDto: CreateFullMetricsGithubUserRepositoryDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsGithubUserRepositoryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubUserRepositoryControllerCreateOne(createFullMetricsGithubUserRepositoryDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubUserRepositoryControllerCreateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubUserRepositoryControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubUserRepositoryControllerDeleteOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubUserRepositoryControllerDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubUserRepositoryControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManyMetricsGithubUserRepositoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubUserRepositoryControllerFindMany(curPage, perPage, searchText, sort, tenantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubUserRepositoryControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubUserRepositoryControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsGithubUserRepositoryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubUserRepositoryControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubUserRepositoryControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetricsGithubUserRepositoryDto} updateMetricsGithubUserRepositoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubUserRepositoryControllerUpdateOne(id: string, updateMetricsGithubUserRepositoryDto: UpdateMetricsGithubUserRepositoryDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsGithubUserRepositoryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubUserRepositoryControllerUpdateOne(id, updateMetricsGithubUserRepositoryDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubUserRepositoryControllerUpdateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateFullMetricsGithubUserStatisticsDto} createFullMetricsGithubUserStatisticsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubUserStatisticsControllerCreateOne(createFullMetricsGithubUserStatisticsDto: CreateFullMetricsGithubUserStatisticsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsGithubUserStatisticsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubUserStatisticsControllerCreateOne(createFullMetricsGithubUserStatisticsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubUserStatisticsControllerCreateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubUserStatisticsControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubUserStatisticsControllerDeleteOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubUserStatisticsControllerDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubUserStatisticsControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManyMetricsGithubUserStatisticsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubUserStatisticsControllerFindMany(curPage, perPage, searchText, sort, tenantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubUserStatisticsControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubUserStatisticsControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsGithubUserStatisticsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubUserStatisticsControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubUserStatisticsControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetricsGithubUserStatisticsDto} updateMetricsGithubUserStatisticsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsGithubUserStatisticsControllerUpdateOne(id: string, updateMetricsGithubUserStatisticsDto: UpdateMetricsGithubUserStatisticsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsGithubUserStatisticsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsGithubUserStatisticsControllerUpdateOne(id, updateMetricsGithubUserStatisticsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsGithubUserStatisticsControllerUpdateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateFullMetricsUserDto} createFullMetricsUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsUserControllerCreateOne(createFullMetricsUserDto: CreateFullMetricsUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsUserControllerCreateOne(createFullMetricsUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsUserControllerCreateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsUserControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsUserControllerDeleteOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsUserControllerDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsUserControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManyMetricsUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsUserControllerFindMany(curPage, perPage, searchText, sort, tenantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsUserControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsUserControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsUserControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsUserControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetricsUserDto} updateMetricsUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsUserControllerUpdateOne(id: string, updateMetricsUserDto: UpdateMetricsUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsUserControllerUpdateOne(id, updateMetricsUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.metricsUserControllerUpdateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetricsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateFullMetricsGithubMetricDto} createFullMetricsGithubMetricDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubMetricControllerCreateOne(createFullMetricsGithubMetricDto: CreateFullMetricsGithubMetricDto, options?: RawAxiosRequestConfig): AxiosPromise<MetricsGithubMetricDto> {
            return localVarFp.metricsGithubMetricControllerCreateOne(createFullMetricsGithubMetricDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubMetricControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.metricsGithubMetricControllerDeleteOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubMetricControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManyMetricsGithubMetricResponse> {
            return localVarFp.metricsGithubMetricControllerFindMany(curPage, perPage, searchText, sort, tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubMetricControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<MetricsGithubMetricDto> {
            return localVarFp.metricsGithubMetricControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetricsGithubMetricDto} updateMetricsGithubMetricDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubMetricControllerUpdateOne(id: string, updateMetricsGithubMetricDto: UpdateMetricsGithubMetricDto, options?: RawAxiosRequestConfig): AxiosPromise<MetricsGithubMetricDto> {
            return localVarFp.metricsGithubMetricControllerUpdateOne(id, updateMetricsGithubMetricDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateMetricsGithubRepositoryDto} createMetricsGithubRepositoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubRepositoryControllerCreateOne(createMetricsGithubRepositoryDto: CreateMetricsGithubRepositoryDto, options?: RawAxiosRequestConfig): AxiosPromise<MetricsGithubRepositoryDto> {
            return localVarFp.metricsGithubRepositoryControllerCreateOne(createMetricsGithubRepositoryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubRepositoryControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.metricsGithubRepositoryControllerDeleteOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubRepositoryControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManyMetricsGithubRepositoryResponse> {
            return localVarFp.metricsGithubRepositoryControllerFindMany(curPage, perPage, searchText, sort, tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubRepositoryControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<MetricsGithubRepositoryDto> {
            return localVarFp.metricsGithubRepositoryControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetricsGithubRepositoryDto} updateMetricsGithubRepositoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubRepositoryControllerUpdateOne(id: string, updateMetricsGithubRepositoryDto: UpdateMetricsGithubRepositoryDto, options?: RawAxiosRequestConfig): AxiosPromise<MetricsGithubRepositoryDto> {
            return localVarFp.metricsGithubRepositoryControllerUpdateOne(id, updateMetricsGithubRepositoryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateFullMetricsGithubRepositoryStatisticsDto} createFullMetricsGithubRepositoryStatisticsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubRepositoryStatisticsControllerCreateOne(createFullMetricsGithubRepositoryStatisticsDto: CreateFullMetricsGithubRepositoryStatisticsDto, options?: RawAxiosRequestConfig): AxiosPromise<MetricsGithubRepositoryStatisticsDto> {
            return localVarFp.metricsGithubRepositoryStatisticsControllerCreateOne(createFullMetricsGithubRepositoryStatisticsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubRepositoryStatisticsControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.metricsGithubRepositoryStatisticsControllerDeleteOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubRepositoryStatisticsControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManyMetricsGithubRepositoryStatisticsResponse> {
            return localVarFp.metricsGithubRepositoryStatisticsControllerFindMany(curPage, perPage, searchText, sort, tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubRepositoryStatisticsControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<MetricsGithubRepositoryStatisticsDto> {
            return localVarFp.metricsGithubRepositoryStatisticsControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetricsGithubRepositoryStatisticsDto} updateMetricsGithubRepositoryStatisticsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubRepositoryStatisticsControllerUpdateOne(id: string, updateMetricsGithubRepositoryStatisticsDto: UpdateMetricsGithubRepositoryStatisticsDto, options?: RawAxiosRequestConfig): AxiosPromise<MetricsGithubRepositoryStatisticsDto> {
            return localVarFp.metricsGithubRepositoryStatisticsControllerUpdateOne(id, updateMetricsGithubRepositoryStatisticsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateMetricsGithubTeamDto} createMetricsGithubTeamDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubTeamControllerCreateOne(createMetricsGithubTeamDto: CreateMetricsGithubTeamDto, options?: RawAxiosRequestConfig): AxiosPromise<MetricsGithubTeamDto> {
            return localVarFp.metricsGithubTeamControllerCreateOne(createMetricsGithubTeamDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubTeamControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.metricsGithubTeamControllerDeleteOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubTeamControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManyMetricsGithubTeamResponse> {
            return localVarFp.metricsGithubTeamControllerFindMany(curPage, perPage, searchText, sort, tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubTeamControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<MetricsGithubTeamDto> {
            return localVarFp.metricsGithubTeamControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetricsGithubTeamDto} updateMetricsGithubTeamDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubTeamControllerUpdateOne(id: string, updateMetricsGithubTeamDto: UpdateMetricsGithubTeamDto, options?: RawAxiosRequestConfig): AxiosPromise<MetricsGithubTeamDto> {
            return localVarFp.metricsGithubTeamControllerUpdateOne(id, updateMetricsGithubTeamDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateFullMetricsGithubTeamRepositoryDto} createFullMetricsGithubTeamRepositoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubTeamRepositoryControllerCreateOne(createFullMetricsGithubTeamRepositoryDto: CreateFullMetricsGithubTeamRepositoryDto, options?: RawAxiosRequestConfig): AxiosPromise<MetricsGithubTeamRepositoryDto> {
            return localVarFp.metricsGithubTeamRepositoryControllerCreateOne(createFullMetricsGithubTeamRepositoryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubTeamRepositoryControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.metricsGithubTeamRepositoryControllerDeleteOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubTeamRepositoryControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManyMetricsGithubTeamRepositoryResponse> {
            return localVarFp.metricsGithubTeamRepositoryControllerFindMany(curPage, perPage, searchText, sort, tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubTeamRepositoryControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<MetricsGithubTeamRepositoryDto> {
            return localVarFp.metricsGithubTeamRepositoryControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetricsGithubTeamRepositoryDto} updateMetricsGithubTeamRepositoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubTeamRepositoryControllerUpdateOne(id: string, updateMetricsGithubTeamRepositoryDto: UpdateMetricsGithubTeamRepositoryDto, options?: RawAxiosRequestConfig): AxiosPromise<MetricsGithubTeamRepositoryDto> {
            return localVarFp.metricsGithubTeamRepositoryControllerUpdateOne(id, updateMetricsGithubTeamRepositoryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateFullMetricsGithubTeamUserDto} createFullMetricsGithubTeamUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubTeamUserControllerCreateOne(createFullMetricsGithubTeamUserDto: CreateFullMetricsGithubTeamUserDto, options?: RawAxiosRequestConfig): AxiosPromise<MetricsGithubTeamUserDto> {
            return localVarFp.metricsGithubTeamUserControllerCreateOne(createFullMetricsGithubTeamUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubTeamUserControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.metricsGithubTeamUserControllerDeleteOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubTeamUserControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManyMetricsGithubTeamUserResponse> {
            return localVarFp.metricsGithubTeamUserControllerFindMany(curPage, perPage, searchText, sort, tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubTeamUserControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<MetricsGithubTeamUserDto> {
            return localVarFp.metricsGithubTeamUserControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetricsGithubTeamUserDto} updateMetricsGithubTeamUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubTeamUserControllerUpdateOne(id: string, updateMetricsGithubTeamUserDto: UpdateMetricsGithubTeamUserDto, options?: RawAxiosRequestConfig): AxiosPromise<MetricsGithubTeamUserDto> {
            return localVarFp.metricsGithubTeamUserControllerUpdateOne(id, updateMetricsGithubTeamUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateMetricsGithubUserDto} createMetricsGithubUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubUserControllerCreateOne(createMetricsGithubUserDto: CreateMetricsGithubUserDto, options?: RawAxiosRequestConfig): AxiosPromise<MetricsGithubUserDto> {
            return localVarFp.metricsGithubUserControllerCreateOne(createMetricsGithubUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubUserControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.metricsGithubUserControllerDeleteOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubUserControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManyMetricsGithubUserResponse> {
            return localVarFp.metricsGithubUserControllerFindMany(curPage, perPage, searchText, sort, tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubUserControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<MetricsGithubUserDto> {
            return localVarFp.metricsGithubUserControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetricsGithubUserDto} updateMetricsGithubUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubUserControllerUpdateOne(id: string, updateMetricsGithubUserDto: UpdateMetricsGithubUserDto, options?: RawAxiosRequestConfig): AxiosPromise<MetricsGithubUserDto> {
            return localVarFp.metricsGithubUserControllerUpdateOne(id, updateMetricsGithubUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateFullMetricsGithubUserRepositoryDto} createFullMetricsGithubUserRepositoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubUserRepositoryControllerCreateOne(createFullMetricsGithubUserRepositoryDto: CreateFullMetricsGithubUserRepositoryDto, options?: RawAxiosRequestConfig): AxiosPromise<MetricsGithubUserRepositoryDto> {
            return localVarFp.metricsGithubUserRepositoryControllerCreateOne(createFullMetricsGithubUserRepositoryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubUserRepositoryControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.metricsGithubUserRepositoryControllerDeleteOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubUserRepositoryControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManyMetricsGithubUserRepositoryResponse> {
            return localVarFp.metricsGithubUserRepositoryControllerFindMany(curPage, perPage, searchText, sort, tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubUserRepositoryControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<MetricsGithubUserRepositoryDto> {
            return localVarFp.metricsGithubUserRepositoryControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetricsGithubUserRepositoryDto} updateMetricsGithubUserRepositoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubUserRepositoryControllerUpdateOne(id: string, updateMetricsGithubUserRepositoryDto: UpdateMetricsGithubUserRepositoryDto, options?: RawAxiosRequestConfig): AxiosPromise<MetricsGithubUserRepositoryDto> {
            return localVarFp.metricsGithubUserRepositoryControllerUpdateOne(id, updateMetricsGithubUserRepositoryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateFullMetricsGithubUserStatisticsDto} createFullMetricsGithubUserStatisticsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubUserStatisticsControllerCreateOne(createFullMetricsGithubUserStatisticsDto: CreateFullMetricsGithubUserStatisticsDto, options?: RawAxiosRequestConfig): AxiosPromise<MetricsGithubUserStatisticsDto> {
            return localVarFp.metricsGithubUserStatisticsControllerCreateOne(createFullMetricsGithubUserStatisticsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubUserStatisticsControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.metricsGithubUserStatisticsControllerDeleteOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubUserStatisticsControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManyMetricsGithubUserStatisticsResponse> {
            return localVarFp.metricsGithubUserStatisticsControllerFindMany(curPage, perPage, searchText, sort, tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubUserStatisticsControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<MetricsGithubUserStatisticsDto> {
            return localVarFp.metricsGithubUserStatisticsControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetricsGithubUserStatisticsDto} updateMetricsGithubUserStatisticsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsGithubUserStatisticsControllerUpdateOne(id: string, updateMetricsGithubUserStatisticsDto: UpdateMetricsGithubUserStatisticsDto, options?: RawAxiosRequestConfig): AxiosPromise<MetricsGithubUserStatisticsDto> {
            return localVarFp.metricsGithubUserStatisticsControllerUpdateOne(id, updateMetricsGithubUserStatisticsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateFullMetricsUserDto} createFullMetricsUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsUserControllerCreateOne(createFullMetricsUserDto: CreateFullMetricsUserDto, options?: RawAxiosRequestConfig): AxiosPromise<MetricsUserDto> {
            return localVarFp.metricsUserControllerCreateOne(createFullMetricsUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsUserControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.metricsUserControllerDeleteOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsUserControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManyMetricsUserResponse> {
            return localVarFp.metricsUserControllerFindMany(curPage, perPage, searchText, sort, tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsUserControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<MetricsUserDto> {
            return localVarFp.metricsUserControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateMetricsUserDto} updateMetricsUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsUserControllerUpdateOne(id: string, updateMetricsUserDto: UpdateMetricsUserDto, options?: RawAxiosRequestConfig): AxiosPromise<MetricsUserDto> {
            return localVarFp.metricsUserControllerUpdateOne(id, updateMetricsUserDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
    /**
     * 
     * @param {CreateFullMetricsGithubMetricDto} createFullMetricsGithubMetricDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubMetricControllerCreateOne(createFullMetricsGithubMetricDto: CreateFullMetricsGithubMetricDto, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubMetricControllerCreateOne(createFullMetricsGithubMetricDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubMetricControllerDeleteOne(id: string, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubMetricControllerDeleteOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {string} [tenantId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubMetricControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubMetricControllerFindMany(curPage, perPage, searchText, sort, tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubMetricControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubMetricControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateMetricsGithubMetricDto} updateMetricsGithubMetricDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubMetricControllerUpdateOne(id: string, updateMetricsGithubMetricDto: UpdateMetricsGithubMetricDto, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubMetricControllerUpdateOne(id, updateMetricsGithubMetricDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateMetricsGithubRepositoryDto} createMetricsGithubRepositoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubRepositoryControllerCreateOne(createMetricsGithubRepositoryDto: CreateMetricsGithubRepositoryDto, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubRepositoryControllerCreateOne(createMetricsGithubRepositoryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubRepositoryControllerDeleteOne(id: string, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubRepositoryControllerDeleteOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {string} [tenantId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubRepositoryControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubRepositoryControllerFindMany(curPage, perPage, searchText, sort, tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubRepositoryControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubRepositoryControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateMetricsGithubRepositoryDto} updateMetricsGithubRepositoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubRepositoryControllerUpdateOne(id: string, updateMetricsGithubRepositoryDto: UpdateMetricsGithubRepositoryDto, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubRepositoryControllerUpdateOne(id, updateMetricsGithubRepositoryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateFullMetricsGithubRepositoryStatisticsDto} createFullMetricsGithubRepositoryStatisticsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubRepositoryStatisticsControllerCreateOne(createFullMetricsGithubRepositoryStatisticsDto: CreateFullMetricsGithubRepositoryStatisticsDto, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubRepositoryStatisticsControllerCreateOne(createFullMetricsGithubRepositoryStatisticsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubRepositoryStatisticsControllerDeleteOne(id: string, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubRepositoryStatisticsControllerDeleteOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {string} [tenantId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubRepositoryStatisticsControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubRepositoryStatisticsControllerFindMany(curPage, perPage, searchText, sort, tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubRepositoryStatisticsControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubRepositoryStatisticsControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateMetricsGithubRepositoryStatisticsDto} updateMetricsGithubRepositoryStatisticsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubRepositoryStatisticsControllerUpdateOne(id: string, updateMetricsGithubRepositoryStatisticsDto: UpdateMetricsGithubRepositoryStatisticsDto, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubRepositoryStatisticsControllerUpdateOne(id, updateMetricsGithubRepositoryStatisticsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateMetricsGithubTeamDto} createMetricsGithubTeamDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubTeamControllerCreateOne(createMetricsGithubTeamDto: CreateMetricsGithubTeamDto, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubTeamControllerCreateOne(createMetricsGithubTeamDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubTeamControllerDeleteOne(id: string, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubTeamControllerDeleteOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {string} [tenantId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubTeamControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubTeamControllerFindMany(curPage, perPage, searchText, sort, tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubTeamControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubTeamControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateMetricsGithubTeamDto} updateMetricsGithubTeamDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubTeamControllerUpdateOne(id: string, updateMetricsGithubTeamDto: UpdateMetricsGithubTeamDto, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubTeamControllerUpdateOne(id, updateMetricsGithubTeamDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateFullMetricsGithubTeamRepositoryDto} createFullMetricsGithubTeamRepositoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubTeamRepositoryControllerCreateOne(createFullMetricsGithubTeamRepositoryDto: CreateFullMetricsGithubTeamRepositoryDto, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubTeamRepositoryControllerCreateOne(createFullMetricsGithubTeamRepositoryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubTeamRepositoryControllerDeleteOne(id: string, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubTeamRepositoryControllerDeleteOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {string} [tenantId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubTeamRepositoryControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubTeamRepositoryControllerFindMany(curPage, perPage, searchText, sort, tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubTeamRepositoryControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubTeamRepositoryControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateMetricsGithubTeamRepositoryDto} updateMetricsGithubTeamRepositoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubTeamRepositoryControllerUpdateOne(id: string, updateMetricsGithubTeamRepositoryDto: UpdateMetricsGithubTeamRepositoryDto, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubTeamRepositoryControllerUpdateOne(id, updateMetricsGithubTeamRepositoryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateFullMetricsGithubTeamUserDto} createFullMetricsGithubTeamUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubTeamUserControllerCreateOne(createFullMetricsGithubTeamUserDto: CreateFullMetricsGithubTeamUserDto, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubTeamUserControllerCreateOne(createFullMetricsGithubTeamUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubTeamUserControllerDeleteOne(id: string, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubTeamUserControllerDeleteOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {string} [tenantId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubTeamUserControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubTeamUserControllerFindMany(curPage, perPage, searchText, sort, tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubTeamUserControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubTeamUserControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateMetricsGithubTeamUserDto} updateMetricsGithubTeamUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubTeamUserControllerUpdateOne(id: string, updateMetricsGithubTeamUserDto: UpdateMetricsGithubTeamUserDto, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubTeamUserControllerUpdateOne(id, updateMetricsGithubTeamUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateMetricsGithubUserDto} createMetricsGithubUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubUserControllerCreateOne(createMetricsGithubUserDto: CreateMetricsGithubUserDto, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubUserControllerCreateOne(createMetricsGithubUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubUserControllerDeleteOne(id: string, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubUserControllerDeleteOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {string} [tenantId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubUserControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubUserControllerFindMany(curPage, perPage, searchText, sort, tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubUserControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubUserControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateMetricsGithubUserDto} updateMetricsGithubUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubUserControllerUpdateOne(id: string, updateMetricsGithubUserDto: UpdateMetricsGithubUserDto, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubUserControllerUpdateOne(id, updateMetricsGithubUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateFullMetricsGithubUserRepositoryDto} createFullMetricsGithubUserRepositoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubUserRepositoryControllerCreateOne(createFullMetricsGithubUserRepositoryDto: CreateFullMetricsGithubUserRepositoryDto, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubUserRepositoryControllerCreateOne(createFullMetricsGithubUserRepositoryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubUserRepositoryControllerDeleteOne(id: string, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubUserRepositoryControllerDeleteOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {string} [tenantId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubUserRepositoryControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubUserRepositoryControllerFindMany(curPage, perPage, searchText, sort, tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubUserRepositoryControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubUserRepositoryControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateMetricsGithubUserRepositoryDto} updateMetricsGithubUserRepositoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubUserRepositoryControllerUpdateOne(id: string, updateMetricsGithubUserRepositoryDto: UpdateMetricsGithubUserRepositoryDto, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubUserRepositoryControllerUpdateOne(id, updateMetricsGithubUserRepositoryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateFullMetricsGithubUserStatisticsDto} createFullMetricsGithubUserStatisticsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubUserStatisticsControllerCreateOne(createFullMetricsGithubUserStatisticsDto: CreateFullMetricsGithubUserStatisticsDto, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubUserStatisticsControllerCreateOne(createFullMetricsGithubUserStatisticsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubUserStatisticsControllerDeleteOne(id: string, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubUserStatisticsControllerDeleteOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {string} [tenantId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubUserStatisticsControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubUserStatisticsControllerFindMany(curPage, perPage, searchText, sort, tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubUserStatisticsControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubUserStatisticsControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateMetricsGithubUserStatisticsDto} updateMetricsGithubUserStatisticsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsGithubUserStatisticsControllerUpdateOne(id: string, updateMetricsGithubUserStatisticsDto: UpdateMetricsGithubUserStatisticsDto, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsGithubUserStatisticsControllerUpdateOne(id, updateMetricsGithubUserStatisticsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateFullMetricsUserDto} createFullMetricsUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsUserControllerCreateOne(createFullMetricsUserDto: CreateFullMetricsUserDto, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsUserControllerCreateOne(createFullMetricsUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsUserControllerDeleteOne(id: string, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsUserControllerDeleteOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {string} [tenantId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsUserControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsUserControllerFindMany(curPage, perPage, searchText, sort, tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsUserControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsUserControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateMetricsUserDto} updateMetricsUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public metricsUserControllerUpdateOne(id: string, updateMetricsUserDto: UpdateMetricsUserDto, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).metricsUserControllerUpdateOne(id, updateMetricsUserDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NotificationsApi - axios parameter creator
 * @export
 */
export const NotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsControllerFindMany: async (curPage?: number, perPage?: number, searchText?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('notificationsControllerFindOne', 'id', id)
            const localVarPath = `/api/notifications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateNotificationsEventDto} updateNotificationsEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsControllerUpdateOne: async (id: string, updateNotificationsEventDto: UpdateNotificationsEventDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('notificationsControllerUpdateOne', 'id', id)
            // verify required parameter 'updateNotificationsEventDto' is not null or undefined
            assertParamExists('notificationsControllerUpdateOne', 'updateNotificationsEventDto', updateNotificationsEventDto)
            const localVarPath = `/api/notifications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateNotificationsEventDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsApi - functional programming interface
 * @export
 */
export const NotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManyNotificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsControllerFindMany(curPage, perPage, searchText, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.notificationsControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationsEventDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.notificationsControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateNotificationsEventDto} updateNotificationsEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsControllerUpdateOne(id: string, updateNotificationsEventDto: UpdateNotificationsEventDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationsEventDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsControllerUpdateOne(id, updateNotificationsEventDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.notificationsControllerUpdateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NotificationsApi - factory interface
 * @export
 */
export const NotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationsApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManyNotificationResponse> {
            return localVarFp.notificationsControllerFindMany(curPage, perPage, searchText, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<NotificationsEventDto> {
            return localVarFp.notificationsControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateNotificationsEventDto} updateNotificationsEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsControllerUpdateOne(id: string, updateNotificationsEventDto: UpdateNotificationsEventDto, options?: RawAxiosRequestConfig): AxiosPromise<NotificationsEventDto> {
            return localVarFp.notificationsControllerUpdateOne(id, updateNotificationsEventDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
export class NotificationsApi extends BaseAPI {
    /**
     * 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notificationsControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsControllerFindMany(curPage, perPage, searchText, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notificationsControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateNotificationsEventDto} updateNotificationsEventDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notificationsControllerUpdateOne(id: string, updateNotificationsEventDto: UpdateNotificationsEventDto, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsControllerUpdateOne(id, updateNotificationsEventDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SsoApi - axios parameter creator
 * @export
 */
export const SsoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CompleteForgotPasswordArgs} completeForgotPasswordArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoControllerCompleteForgotPassword: async (completeForgotPasswordArgs: CompleteForgotPasswordArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'completeForgotPasswordArgs' is not null or undefined
            assertParamExists('ssoControllerCompleteForgotPassword', 'completeForgotPasswordArgs', completeForgotPasswordArgs)
            const localVarPath = `/api/sso/complete-forgot-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(completeForgotPasswordArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CompleteSignUpArgs} completeSignUpArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoControllerCompleteSignUp: async (completeSignUpArgs: CompleteSignUpArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'completeSignUpArgs' is not null or undefined
            assertParamExists('ssoControllerCompleteSignUp', 'completeSignUpArgs', completeSignUpArgs)
            const localVarPath = `/api/sso/complete-sign-up`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(completeSignUpArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ForgotPasswordArgs} forgotPasswordArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoControllerForgotPassword: async (forgotPasswordArgs: ForgotPasswordArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forgotPasswordArgs' is not null or undefined
            assertParamExists('ssoControllerForgotPassword', 'forgotPasswordArgs', forgotPasswordArgs)
            const localVarPath = `/api/sso/forgot-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgotPasswordArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoControllerProfile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RefreshTokensResponse} refreshTokensResponse 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoControllerRefreshTokens: async (refreshTokensResponse: RefreshTokensResponse, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokensResponse' is not null or undefined
            assertParamExists('ssoControllerRefreshTokens', 'refreshTokensResponse', refreshTokensResponse)
            const localVarPath = `/api/sso/refresh-tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokensResponse, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignInArgs} signInArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoControllerSignIn: async (signInArgs: SignInArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signInArgs' is not null or undefined
            assertParamExists('ssoControllerSignIn', 'signInArgs', signInArgs)
            const localVarPath = `/api/sso/sign-in`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signInArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignOutArgs} signOutArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoControllerSignOut: async (signOutArgs: SignOutArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signOutArgs' is not null or undefined
            assertParamExists('ssoControllerSignOut', 'signOutArgs', signOutArgs)
            const localVarPath = `/api/sso/sign-out`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signOutArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignUpArgs} signUpArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoControllerSignUp: async (signUpArgs: SignUpArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signUpArgs' is not null or undefined
            assertParamExists('ssoControllerSignUp', 'signUpArgs', signUpArgs)
            const localVarPath = `/api/sso/sign-up`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUpArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateProfileArgs} updateProfileArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoControllerUpdateProfile: async (updateProfileArgs: UpdateProfileArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateProfileArgs' is not null or undefined
            assertParamExists('ssoControllerUpdateProfile', 'updateProfileArgs', updateProfileArgs)
            const localVarPath = `/api/sso/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProfileArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoEmailTemplatesControllerFindMany: async (curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/email-templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenantId'] = tenantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoEmailTemplatesControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ssoEmailTemplatesControllerFindOne', 'id', id)
            const localVarPath = `/api/sso/email-templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateSsoEmailTemplateDto} updateSsoEmailTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoEmailTemplatesControllerUpdateOne: async (id: string, updateSsoEmailTemplateDto: UpdateSsoEmailTemplateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ssoEmailTemplatesControllerUpdateOne', 'id', id)
            // verify required parameter 'updateSsoEmailTemplateDto' is not null or undefined
            assertParamExists('ssoEmailTemplatesControllerUpdateOne', 'updateSsoEmailTemplateDto', updateSsoEmailTemplateDto)
            const localVarPath = `/api/sso/email-templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSsoEmailTemplateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} redirectUri 
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoGoogleOAuthControllerGoogleAuth: async (redirectUri: string, clientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'redirectUri' is not null or undefined
            assertParamExists('ssoGoogleOAuthControllerGoogleAuth', 'redirectUri', redirectUri)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('ssoGoogleOAuthControllerGoogleAuth', 'clientId', clientId)
            const localVarPath = `/api/sso/oauth/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['client_id'] = clientId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} redirectUri 
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoGoogleOAuthControllerGoogleAuthRedirect: async (redirectUri: string, clientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'redirectUri' is not null or undefined
            assertParamExists('ssoGoogleOAuthControllerGoogleAuthRedirect', 'redirectUri', redirectUri)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('ssoGoogleOAuthControllerGoogleAuthRedirect', 'clientId', clientId)
            const localVarPath = `/api/sso/oauth/google/redirect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['client_id'] = clientId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoOAuthControllerOauthProviders: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/oauth/providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SsoOAuthVerificationArgs} ssoOAuthVerificationArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoOAuthControllerOauthVerification: async (ssoOAuthVerificationArgs: SsoOAuthVerificationArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ssoOAuthVerificationArgs' is not null or undefined
            assertParamExists('ssoOAuthControllerOauthVerification', 'ssoOAuthVerificationArgs', ssoOAuthVerificationArgs)
            const localVarPath = `/api/sso/oauth/verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ssoOAuthVerificationArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoPublicTenantsControllerFindMany: async (curPage?: number, perPage?: number, searchText?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/public-tenants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoRefreshSessionsControllerFindMany: async (userId: string, curPage?: number, perPage?: number, searchText?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('ssoRefreshSessionsControllerFindMany', 'userId', userId)
            const localVarPath = `/api/sso/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoRefreshSessionsControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ssoRefreshSessionsControllerFindOne', 'id', id)
            const localVarPath = `/api/sso/sessions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateSsoRefreshSessionDto} updateSsoRefreshSessionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoRefreshSessionsControllerUpdateOne: async (id: string, updateSsoRefreshSessionDto: UpdateSsoRefreshSessionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ssoRefreshSessionsControllerUpdateOne', 'id', id)
            // verify required parameter 'updateSsoRefreshSessionDto' is not null or undefined
            assertParamExists('ssoRefreshSessionsControllerUpdateOne', 'updateSsoRefreshSessionDto', updateSsoRefreshSessionDto)
            const localVarPath = `/api/sso/sessions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSsoRefreshSessionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoRolesControllerFindMany: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateSsoTenantDto} createSsoTenantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoTenantsControllerCreateOne: async (createSsoTenantDto: CreateSsoTenantDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createSsoTenantDto' is not null or undefined
            assertParamExists('ssoTenantsControllerCreateOne', 'createSsoTenantDto', createSsoTenantDto)
            const localVarPath = `/api/sso/tenants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSsoTenantDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoTenantsControllerDeleteOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ssoTenantsControllerDeleteOne', 'id', id)
            const localVarPath = `/api/sso/tenants/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoTenantsControllerFindMany: async (curPage?: number, perPage?: number, searchText?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/tenants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoTenantsControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ssoTenantsControllerFindOne', 'id', id)
            const localVarPath = `/api/sso/tenants/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateSsoTenantDto} updateSsoTenantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoTenantsControllerUpdateOne: async (id: string, updateSsoTenantDto: UpdateSsoTenantDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ssoTenantsControllerUpdateOne', 'id', id)
            // verify required parameter 'updateSsoTenantDto' is not null or undefined
            assertParamExists('ssoTenantsControllerUpdateOne', 'updateSsoTenantDto', updateSsoTenantDto)
            const localVarPath = `/api/sso/tenants/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSsoTenantDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoUsersControllerFindMany: async (curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenantId'] = tenantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoUsersControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ssoUsersControllerFindOne', 'id', id)
            const localVarPath = `/api/sso/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SendInvitationLinksArgs} sendInvitationLinksArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoUsersControllerSendInvitationLinks: async (sendInvitationLinksArgs: SendInvitationLinksArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendInvitationLinksArgs' is not null or undefined
            assertParamExists('ssoUsersControllerSendInvitationLinks', 'sendInvitationLinksArgs', sendInvitationLinksArgs)
            const localVarPath = `/api/sso/users/send-invitation-links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendInvitationLinksArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateSsoUserDto} updateSsoUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoUsersControllerUpdateOne: async (id: string, updateSsoUserDto: UpdateSsoUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ssoUsersControllerUpdateOne', 'id', id)
            // verify required parameter 'updateSsoUserDto' is not null or undefined
            assertParamExists('ssoUsersControllerUpdateOne', 'updateSsoUserDto', updateSsoUserDto)
            const localVarPath = `/api/sso/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSsoUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SsoApi - functional programming interface
 * @export
 */
export const SsoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SsoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CompleteForgotPasswordArgs} completeForgotPasswordArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoControllerCompleteForgotPassword(completeForgotPasswordArgs: CompleteForgotPasswordArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokensResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoControllerCompleteForgotPassword(completeForgotPasswordArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoControllerCompleteForgotPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CompleteSignUpArgs} completeSignUpArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoControllerCompleteSignUp(completeSignUpArgs: CompleteSignUpArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokensResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoControllerCompleteSignUp(completeSignUpArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoControllerCompleteSignUp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ForgotPasswordArgs} forgotPasswordArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoControllerForgotPassword(forgotPasswordArgs: ForgotPasswordArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoControllerForgotPassword(forgotPasswordArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoControllerForgotPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoControllerProfile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SsoUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoControllerProfile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoControllerProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RefreshTokensResponse} refreshTokensResponse 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoControllerRefreshTokens(refreshTokensResponse: RefreshTokensResponse, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokensResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoControllerRefreshTokens(refreshTokensResponse, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoControllerRefreshTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SignInArgs} signInArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoControllerSignIn(signInArgs: SignInArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokensResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoControllerSignIn(signInArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoControllerSignIn']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SignOutArgs} signOutArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoControllerSignOut(signOutArgs: SignOutArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoControllerSignOut(signOutArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoControllerSignOut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SignUpArgs} signUpArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoControllerSignUp(signUpArgs: SignUpArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokensResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoControllerSignUp(signUpArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoControllerSignUp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateProfileArgs} updateProfileArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoControllerUpdateProfile(updateProfileArgs: UpdateProfileArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SsoUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoControllerUpdateProfile(updateProfileArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoControllerUpdateProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoEmailTemplatesControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManySsoEmailTemplateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoEmailTemplatesControllerFindMany(curPage, perPage, searchText, sort, tenantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoEmailTemplatesControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoEmailTemplatesControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SsoEmailTemplateDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoEmailTemplatesControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoEmailTemplatesControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateSsoEmailTemplateDto} updateSsoEmailTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoEmailTemplatesControllerUpdateOne(id: string, updateSsoEmailTemplateDto: UpdateSsoEmailTemplateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SsoEmailTemplateDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoEmailTemplatesControllerUpdateOne(id, updateSsoEmailTemplateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoEmailTemplatesControllerUpdateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} redirectUri 
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoGoogleOAuthControllerGoogleAuth(redirectUri: string, clientId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoGoogleOAuthControllerGoogleAuth(redirectUri, clientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoGoogleOAuthControllerGoogleAuth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} redirectUri 
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoGoogleOAuthControllerGoogleAuthRedirect(redirectUri: string, clientId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoGoogleOAuthControllerGoogleAuthRedirect(redirectUri, clientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoGoogleOAuthControllerGoogleAuthRedirect']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoOAuthControllerOauthProviders(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OAuthProvider>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoOAuthControllerOauthProviders(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoOAuthControllerOauthProviders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SsoOAuthVerificationArgs} ssoOAuthVerificationArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoOAuthControllerOauthVerification(ssoOAuthVerificationArgs: SsoOAuthVerificationArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokensResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoOAuthControllerOauthVerification(ssoOAuthVerificationArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoOAuthControllerOauthVerification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoPublicTenantsControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManySsoPublicTenantResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoPublicTenantsControllerFindMany(curPage, perPage, searchText, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoPublicTenantsControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoRefreshSessionsControllerFindMany(userId: string, curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManySsoRefreshSessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoRefreshSessionsControllerFindMany(userId, curPage, perPage, searchText, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoRefreshSessionsControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoRefreshSessionsControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SsoRefreshSessionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoRefreshSessionsControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoRefreshSessionsControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateSsoRefreshSessionDto} updateSsoRefreshSessionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoRefreshSessionsControllerUpdateOne(id: string, updateSsoRefreshSessionDto: UpdateSsoRefreshSessionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SsoRefreshSessionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoRefreshSessionsControllerUpdateOne(id, updateSsoRefreshSessionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoRefreshSessionsControllerUpdateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoRolesControllerFindMany(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManySsoRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoRolesControllerFindMany(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoRolesControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateSsoTenantDto} createSsoTenantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoTenantsControllerCreateOne(createSsoTenantDto: CreateSsoTenantDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SsoTenantDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoTenantsControllerCreateOne(createSsoTenantDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoTenantsControllerCreateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoTenantsControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoTenantsControllerDeleteOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoTenantsControllerDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoTenantsControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManySsoTenantResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoTenantsControllerFindMany(curPage, perPage, searchText, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoTenantsControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoTenantsControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SsoTenantDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoTenantsControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoTenantsControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateSsoTenantDto} updateSsoTenantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoTenantsControllerUpdateOne(id: string, updateSsoTenantDto: UpdateSsoTenantDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SsoTenantDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoTenantsControllerUpdateOne(id, updateSsoTenantDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoTenantsControllerUpdateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoUsersControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManySsoUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoUsersControllerFindMany(curPage, perPage, searchText, sort, tenantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoUsersControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoUsersControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SsoUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoUsersControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoUsersControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SendInvitationLinksArgs} sendInvitationLinksArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoUsersControllerSendInvitationLinks(sendInvitationLinksArgs: SendInvitationLinksArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoUsersControllerSendInvitationLinks(sendInvitationLinksArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoUsersControllerSendInvitationLinks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateSsoUserDto} updateSsoUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoUsersControllerUpdateOne(id: string, updateSsoUserDto: UpdateSsoUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SsoUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoUsersControllerUpdateOne(id, updateSsoUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoUsersControllerUpdateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SsoApi - factory interface
 * @export
 */
export const SsoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SsoApiFp(configuration)
    return {
        /**
         * 
         * @param {CompleteForgotPasswordArgs} completeForgotPasswordArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoControllerCompleteForgotPassword(completeForgotPasswordArgs: CompleteForgotPasswordArgs, options?: RawAxiosRequestConfig): AxiosPromise<TokensResponse> {
            return localVarFp.ssoControllerCompleteForgotPassword(completeForgotPasswordArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CompleteSignUpArgs} completeSignUpArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoControllerCompleteSignUp(completeSignUpArgs: CompleteSignUpArgs, options?: RawAxiosRequestConfig): AxiosPromise<TokensResponse> {
            return localVarFp.ssoControllerCompleteSignUp(completeSignUpArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ForgotPasswordArgs} forgotPasswordArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoControllerForgotPassword(forgotPasswordArgs: ForgotPasswordArgs, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.ssoControllerForgotPassword(forgotPasswordArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoControllerProfile(options?: RawAxiosRequestConfig): AxiosPromise<SsoUserDto> {
            return localVarFp.ssoControllerProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RefreshTokensResponse} refreshTokensResponse 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoControllerRefreshTokens(refreshTokensResponse: RefreshTokensResponse, options?: RawAxiosRequestConfig): AxiosPromise<TokensResponse> {
            return localVarFp.ssoControllerRefreshTokens(refreshTokensResponse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SignInArgs} signInArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoControllerSignIn(signInArgs: SignInArgs, options?: RawAxiosRequestConfig): AxiosPromise<TokensResponse> {
            return localVarFp.ssoControllerSignIn(signInArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SignOutArgs} signOutArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoControllerSignOut(signOutArgs: SignOutArgs, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.ssoControllerSignOut(signOutArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SignUpArgs} signUpArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoControllerSignUp(signUpArgs: SignUpArgs, options?: RawAxiosRequestConfig): AxiosPromise<TokensResponse> {
            return localVarFp.ssoControllerSignUp(signUpArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateProfileArgs} updateProfileArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoControllerUpdateProfile(updateProfileArgs: UpdateProfileArgs, options?: RawAxiosRequestConfig): AxiosPromise<SsoUserDto> {
            return localVarFp.ssoControllerUpdateProfile(updateProfileArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoEmailTemplatesControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManySsoEmailTemplateResponse> {
            return localVarFp.ssoEmailTemplatesControllerFindMany(curPage, perPage, searchText, sort, tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoEmailTemplatesControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<SsoEmailTemplateDto> {
            return localVarFp.ssoEmailTemplatesControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateSsoEmailTemplateDto} updateSsoEmailTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoEmailTemplatesControllerUpdateOne(id: string, updateSsoEmailTemplateDto: UpdateSsoEmailTemplateDto, options?: RawAxiosRequestConfig): AxiosPromise<SsoEmailTemplateDto> {
            return localVarFp.ssoEmailTemplatesControllerUpdateOne(id, updateSsoEmailTemplateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} redirectUri 
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoGoogleOAuthControllerGoogleAuth(redirectUri: string, clientId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.ssoGoogleOAuthControllerGoogleAuth(redirectUri, clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} redirectUri 
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoGoogleOAuthControllerGoogleAuthRedirect(redirectUri: string, clientId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.ssoGoogleOAuthControllerGoogleAuthRedirect(redirectUri, clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoOAuthControllerOauthProviders(options?: RawAxiosRequestConfig): AxiosPromise<Array<OAuthProvider>> {
            return localVarFp.ssoOAuthControllerOauthProviders(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SsoOAuthVerificationArgs} ssoOAuthVerificationArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoOAuthControllerOauthVerification(ssoOAuthVerificationArgs: SsoOAuthVerificationArgs, options?: RawAxiosRequestConfig): AxiosPromise<TokensResponse> {
            return localVarFp.ssoOAuthControllerOauthVerification(ssoOAuthVerificationArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoPublicTenantsControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManySsoPublicTenantResponse> {
            return localVarFp.ssoPublicTenantsControllerFindMany(curPage, perPage, searchText, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoRefreshSessionsControllerFindMany(userId: string, curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManySsoRefreshSessionResponse> {
            return localVarFp.ssoRefreshSessionsControllerFindMany(userId, curPage, perPage, searchText, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoRefreshSessionsControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<SsoRefreshSessionDto> {
            return localVarFp.ssoRefreshSessionsControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateSsoRefreshSessionDto} updateSsoRefreshSessionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoRefreshSessionsControllerUpdateOne(id: string, updateSsoRefreshSessionDto: UpdateSsoRefreshSessionDto, options?: RawAxiosRequestConfig): AxiosPromise<SsoRefreshSessionDto> {
            return localVarFp.ssoRefreshSessionsControllerUpdateOne(id, updateSsoRefreshSessionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoRolesControllerFindMany(options?: RawAxiosRequestConfig): AxiosPromise<FindManySsoRoleResponse> {
            return localVarFp.ssoRolesControllerFindMany(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateSsoTenantDto} createSsoTenantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoTenantsControllerCreateOne(createSsoTenantDto: CreateSsoTenantDto, options?: RawAxiosRequestConfig): AxiosPromise<SsoTenantDto> {
            return localVarFp.ssoTenantsControllerCreateOne(createSsoTenantDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoTenantsControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.ssoTenantsControllerDeleteOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoTenantsControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManySsoTenantResponse> {
            return localVarFp.ssoTenantsControllerFindMany(curPage, perPage, searchText, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoTenantsControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<SsoTenantDto> {
            return localVarFp.ssoTenantsControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateSsoTenantDto} updateSsoTenantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoTenantsControllerUpdateOne(id: string, updateSsoTenantDto: UpdateSsoTenantDto, options?: RawAxiosRequestConfig): AxiosPromise<SsoTenantDto> {
            return localVarFp.ssoTenantsControllerUpdateOne(id, updateSsoTenantDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoUsersControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManySsoUserResponse> {
            return localVarFp.ssoUsersControllerFindMany(curPage, perPage, searchText, sort, tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoUsersControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<SsoUserDto> {
            return localVarFp.ssoUsersControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SendInvitationLinksArgs} sendInvitationLinksArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoUsersControllerSendInvitationLinks(sendInvitationLinksArgs: SendInvitationLinksArgs, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.ssoUsersControllerSendInvitationLinks(sendInvitationLinksArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateSsoUserDto} updateSsoUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoUsersControllerUpdateOne(id: string, updateSsoUserDto: UpdateSsoUserDto, options?: RawAxiosRequestConfig): AxiosPromise<SsoUserDto> {
            return localVarFp.ssoUsersControllerUpdateOne(id, updateSsoUserDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SsoApi - object-oriented interface
 * @export
 * @class SsoApi
 * @extends {BaseAPI}
 */
export class SsoApi extends BaseAPI {
    /**
     * 
     * @param {CompleteForgotPasswordArgs} completeForgotPasswordArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoControllerCompleteForgotPassword(completeForgotPasswordArgs: CompleteForgotPasswordArgs, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoControllerCompleteForgotPassword(completeForgotPasswordArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CompleteSignUpArgs} completeSignUpArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoControllerCompleteSignUp(completeSignUpArgs: CompleteSignUpArgs, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoControllerCompleteSignUp(completeSignUpArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ForgotPasswordArgs} forgotPasswordArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoControllerForgotPassword(forgotPasswordArgs: ForgotPasswordArgs, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoControllerForgotPassword(forgotPasswordArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoControllerProfile(options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoControllerProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RefreshTokensResponse} refreshTokensResponse 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoControllerRefreshTokens(refreshTokensResponse: RefreshTokensResponse, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoControllerRefreshTokens(refreshTokensResponse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SignInArgs} signInArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoControllerSignIn(signInArgs: SignInArgs, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoControllerSignIn(signInArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SignOutArgs} signOutArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoControllerSignOut(signOutArgs: SignOutArgs, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoControllerSignOut(signOutArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SignUpArgs} signUpArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoControllerSignUp(signUpArgs: SignUpArgs, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoControllerSignUp(signUpArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateProfileArgs} updateProfileArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoControllerUpdateProfile(updateProfileArgs: UpdateProfileArgs, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoControllerUpdateProfile(updateProfileArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {string} [tenantId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoEmailTemplatesControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoEmailTemplatesControllerFindMany(curPage, perPage, searchText, sort, tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoEmailTemplatesControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoEmailTemplatesControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateSsoEmailTemplateDto} updateSsoEmailTemplateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoEmailTemplatesControllerUpdateOne(id: string, updateSsoEmailTemplateDto: UpdateSsoEmailTemplateDto, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoEmailTemplatesControllerUpdateOne(id, updateSsoEmailTemplateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} redirectUri 
     * @param {string} clientId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoGoogleOAuthControllerGoogleAuth(redirectUri: string, clientId: string, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoGoogleOAuthControllerGoogleAuth(redirectUri, clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} redirectUri 
     * @param {string} clientId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoGoogleOAuthControllerGoogleAuthRedirect(redirectUri: string, clientId: string, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoGoogleOAuthControllerGoogleAuthRedirect(redirectUri, clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoOAuthControllerOauthProviders(options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoOAuthControllerOauthProviders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SsoOAuthVerificationArgs} ssoOAuthVerificationArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoOAuthControllerOauthVerification(ssoOAuthVerificationArgs: SsoOAuthVerificationArgs, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoOAuthControllerOauthVerification(ssoOAuthVerificationArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoPublicTenantsControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoPublicTenantsControllerFindMany(curPage, perPage, searchText, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoRefreshSessionsControllerFindMany(userId: string, curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoRefreshSessionsControllerFindMany(userId, curPage, perPage, searchText, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoRefreshSessionsControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoRefreshSessionsControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateSsoRefreshSessionDto} updateSsoRefreshSessionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoRefreshSessionsControllerUpdateOne(id: string, updateSsoRefreshSessionDto: UpdateSsoRefreshSessionDto, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoRefreshSessionsControllerUpdateOne(id, updateSsoRefreshSessionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoRolesControllerFindMany(options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoRolesControllerFindMany(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateSsoTenantDto} createSsoTenantDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoTenantsControllerCreateOne(createSsoTenantDto: CreateSsoTenantDto, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoTenantsControllerCreateOne(createSsoTenantDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoTenantsControllerDeleteOne(id: string, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoTenantsControllerDeleteOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoTenantsControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoTenantsControllerFindMany(curPage, perPage, searchText, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoTenantsControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoTenantsControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateSsoTenantDto} updateSsoTenantDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoTenantsControllerUpdateOne(id: string, updateSsoTenantDto: UpdateSsoTenantDto, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoTenantsControllerUpdateOne(id, updateSsoTenantDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {string} [tenantId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoUsersControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoUsersControllerFindMany(curPage, perPage, searchText, sort, tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoUsersControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoUsersControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SendInvitationLinksArgs} sendInvitationLinksArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoUsersControllerSendInvitationLinks(sendInvitationLinksArgs: SendInvitationLinksArgs, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoUsersControllerSendInvitationLinks(sendInvitationLinksArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateSsoUserDto} updateSsoUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoUsersControllerUpdateOne(id: string, updateSsoUserDto: UpdateSsoUserDto, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoUsersControllerUpdateOne(id, updateSsoUserDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TerminusHealthCheckApi - axios parameter creator
 * @export
 */
export const TerminusHealthCheckApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminusHealthCheckControllerCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TerminusHealthCheckApi - functional programming interface
 * @export
 */
export const TerminusHealthCheckApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TerminusHealthCheckApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async terminusHealthCheckControllerCheck(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TerminusHealthCheckControllerCheck200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.terminusHealthCheckControllerCheck(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TerminusHealthCheckApi.terminusHealthCheckControllerCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TerminusHealthCheckApi - factory interface
 * @export
 */
export const TerminusHealthCheckApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TerminusHealthCheckApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminusHealthCheckControllerCheck(options?: RawAxiosRequestConfig): AxiosPromise<TerminusHealthCheckControllerCheck200Response> {
            return localVarFp.terminusHealthCheckControllerCheck(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TerminusHealthCheckApi - object-oriented interface
 * @export
 * @class TerminusHealthCheckApi
 * @extends {BaseAPI}
 */
export class TerminusHealthCheckApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerminusHealthCheckApi
     */
    public terminusHealthCheckControllerCheck(options?: RawAxiosRequestConfig) {
        return TerminusHealthCheckApiFp(this.configuration).terminusHealthCheckControllerCheck(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TimeApi - axios parameter creator
 * @export
 */
export const TimeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeControllerTime: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/time`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimeApi - functional programming interface
 * @export
 */
export const TimeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TimeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timeControllerTime(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timeControllerTime(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimeApi.timeControllerTime']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TimeApi - factory interface
 * @export
 */
export const TimeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TimeApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeControllerTime(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.timeControllerTime(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TimeApi - object-oriented interface
 * @export
 * @class TimeApi
 * @extends {BaseAPI}
 */
export class TimeApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeApi
     */
    public timeControllerTime(options?: RawAxiosRequestConfig) {
        return TimeApiFp(this.configuration).timeControllerTime(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebhookApi - axios parameter creator
 * @export
 */
export const WebhookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateWebhookDto} createWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerCreateOne: async (createWebhookDto: CreateWebhookDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWebhookDto' is not null or undefined
            assertParamExists('webhookControllerCreateOne', 'createWebhookDto', createWebhookDto)
            const localVarPath = `/api/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWebhookDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerDeleteOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('webhookControllerDeleteOne', 'id', id)
            const localVarPath = `/api/webhook/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerEvents: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/webhook/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerFindMany: async (curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenantId'] = tenantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('webhookControllerFindOne', 'id', id)
            const localVarPath = `/api/webhook/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerProfile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/webhook/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateWebhookDto} createWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerTestRequest: async (createWebhookDto: CreateWebhookDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWebhookDto' is not null or undefined
            assertParamExists('webhookControllerTestRequest', 'createWebhookDto', createWebhookDto)
            const localVarPath = `/api/webhook/test-request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWebhookDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateWebhookDto} updateWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerUpdateOne: async (id: string, updateWebhookDto: UpdateWebhookDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('webhookControllerUpdateOne', 'id', id)
            // verify required parameter 'updateWebhookDto' is not null or undefined
            assertParamExists('webhookControllerUpdateOne', 'updateWebhookDto', updateWebhookDto)
            const localVarPath = `/api/webhook/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWebhookDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookLogsControllerDeleteOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('webhookLogsControllerDeleteOne', 'id', id)
            const localVarPath = `/api/webhook/logs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookLogsControllerFindManyLogs: async (webhookId: string, curPage?: number, perPage?: number, searchText?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('webhookLogsControllerFindManyLogs', 'webhookId', webhookId)
            const localVarPath = `/api/webhook/logs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (webhookId !== undefined) {
                localVarQueryParameter['webhookId'] = webhookId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookLogsControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('webhookLogsControllerFindOne', 'id', id)
            const localVarPath = `/api/webhook/logs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhookApi - functional programming interface
 * @export
 */
export const WebhookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhookApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateWebhookDto} createWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerCreateOne(createWebhookDto: CreateWebhookDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerCreateOne(createWebhookDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerCreateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerDeleteOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerEvents(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebhookEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerEvents(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManyWebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerFindMany(curPage, perPage, searchText, sort, tenantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerProfile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerProfile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateWebhookDto} createWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerTestRequest(createWebhookDto: CreateWebhookDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookTestRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerTestRequest(createWebhookDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerTestRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateWebhookDto} updateWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerUpdateOne(id: string, updateWebhookDto: UpdateWebhookDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerUpdateOne(id, updateWebhookDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerUpdateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookLogsControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookLogsControllerDeleteOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookLogsControllerDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookLogsControllerFindManyLogs(webhookId: string, curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManyWebhookLogResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookLogsControllerFindManyLogs(webhookId, curPage, perPage, searchText, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookLogsControllerFindManyLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookLogsControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookLogsControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookLogsControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhookApi - factory interface
 * @export
 */
export const WebhookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhookApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateWebhookDto} createWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerCreateOne(createWebhookDto: CreateWebhookDto, options?: RawAxiosRequestConfig): AxiosPromise<Webhook> {
            return localVarFp.webhookControllerCreateOne(createWebhookDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.webhookControllerDeleteOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerEvents(options?: RawAxiosRequestConfig): AxiosPromise<Array<WebhookEvent>> {
            return localVarFp.webhookControllerEvents(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManyWebhookResponse> {
            return localVarFp.webhookControllerFindMany(curPage, perPage, searchText, sort, tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Webhook> {
            return localVarFp.webhookControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerProfile(options?: RawAxiosRequestConfig): AxiosPromise<WebhookUser> {
            return localVarFp.webhookControllerProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateWebhookDto} createWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerTestRequest(createWebhookDto: CreateWebhookDto, options?: RawAxiosRequestConfig): AxiosPromise<WebhookTestRequestResponse> {
            return localVarFp.webhookControllerTestRequest(createWebhookDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateWebhookDto} updateWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerUpdateOne(id: string, updateWebhookDto: UpdateWebhookDto, options?: RawAxiosRequestConfig): AxiosPromise<Webhook> {
            return localVarFp.webhookControllerUpdateOne(id, updateWebhookDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookLogsControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.webhookLogsControllerDeleteOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookLogsControllerFindManyLogs(webhookId: string, curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManyWebhookLogResponse> {
            return localVarFp.webhookLogsControllerFindManyLogs(webhookId, curPage, perPage, searchText, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookLogsControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<WebhookLog> {
            return localVarFp.webhookLogsControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhookApi - object-oriented interface
 * @export
 * @class WebhookApi
 * @extends {BaseAPI}
 */
export class WebhookApi extends BaseAPI {
    /**
     * 
     * @param {CreateWebhookDto} createWebhookDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerCreateOne(createWebhookDto: CreateWebhookDto, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerCreateOne(createWebhookDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerDeleteOne(id: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerDeleteOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerEvents(options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerEvents(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {string} [tenantId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerFindMany(curPage, perPage, searchText, sort, tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerProfile(options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateWebhookDto} createWebhookDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerTestRequest(createWebhookDto: CreateWebhookDto, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerTestRequest(createWebhookDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateWebhookDto} updateWebhookDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerUpdateOne(id: string, updateWebhookDto: UpdateWebhookDto, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerUpdateOne(id, updateWebhookDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookLogsControllerDeleteOne(id: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookLogsControllerDeleteOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} webhookId 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookLogsControllerFindManyLogs(webhookId: string, curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookLogsControllerFindManyLogs(webhookId, curPage, perPage, searchText, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookLogsControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookLogsControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }
}



