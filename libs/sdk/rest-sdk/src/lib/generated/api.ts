/* tslint:disable */
/* eslint-disable */
/**
 * 
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface CompleteForgotPasswordArgs
 */
export interface CompleteForgotPasswordArgs {
    /**
     * 
     * @type {string}
     * @memberof CompleteForgotPasswordArgs
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof CompleteForgotPasswordArgs
     */
    'confirmPassword': string;
    /**
     * 
     * @type {string}
     * @memberof CompleteForgotPasswordArgs
     */
    'fingerprint': string;
    /**
     * 
     * @type {string}
     * @memberof CompleteForgotPasswordArgs
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface CompleteSignUpArgs
 */
export interface CompleteSignUpArgs {
    /**
     * 
     * @type {string}
     * @memberof CompleteSignUpArgs
     */
    'fingerprint': string;
    /**
     * 
     * @type {string}
     * @memberof CompleteSignUpArgs
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface CreateSsoTenantDto
 */
export interface CreateSsoTenantDto {
    /**
     * 
     * @type {string}
     * @memberof CreateSsoTenantDto
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof CreateSsoTenantDto
     */
    'name': string;
    /**
     * 
     * @type {object}
     * @memberof CreateSsoTenantDto
     */
    'nameLocale'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof CreateSsoTenantDto
     */
    'clientId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateSsoTenantDto
     */
    'clientSecret': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateSsoTenantDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateSsoTenantDto
     */
    'public': boolean;
}
/**
 * 
 * @export
 * @interface CreateWebhookDto
 */
export interface CreateWebhookDto {
    /**
     * 
     * @type {string}
     * @memberof CreateWebhookDto
     */
    'eventName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateWebhookDto
     */
    'endpoint': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateWebhookDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {object}
     * @memberof CreateWebhookDto
     */
    'headers'?: object | null;
    /**
     * 
     * @type {number}
     * @memberof CreateWebhookDto
     */
    'requestTimeout'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CreateWebhookDto
     */
    'workUntilDate'?: string | null;
}
/**
 * 
 * @export
 * @interface FilesError
 */
export interface FilesError {
    /**
     * Files error (FILES-000), Forbidden (FILES-001)
     * @type {string}
     * @memberof FilesError
     */
    'message': string;
    /**
     * 
     * @type {FilesErrorEnum}
     * @memberof FilesError
     */
    'code': FilesErrorEnum;
    /**
     * 
     * @type {object}
     * @memberof FilesError
     */
    'metadata'?: object;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const FilesErrorEnum = {
    Files000: 'FILES-000',
    Files001: 'FILES-001'
} as const;

export type FilesErrorEnum = typeof FilesErrorEnum[keyof typeof FilesErrorEnum];


/**
 * 
 * @export
 * @interface FilesPresignedUrls
 */
export interface FilesPresignedUrls {
    /**
     * 
     * @type {string}
     * @memberof FilesPresignedUrls
     */
    'downloadUrl': string;
    /**
     * 
     * @type {string}
     * @memberof FilesPresignedUrls
     */
    'uploadUrl': string;
}
/**
 * 
 * @export
 * @interface FindManyNotificationResponse
 */
export interface FindManyNotificationResponse {
    /**
     * 
     * @type {Array<NotificationsEvent>}
     * @memberof FindManyNotificationResponse
     */
    'notifications': Array<NotificationsEvent>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManyNotificationResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface FindManyResponseMeta
 */
export interface FindManyResponseMeta {
    /**
     * 
     * @type {number}
     * @memberof FindManyResponseMeta
     */
    'curPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof FindManyResponseMeta
     */
    'perPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof FindManyResponseMeta
     */
    'totalResults': number;
}
/**
 * 
 * @export
 * @interface FindManySsoEmailTemplateResponse
 */
export interface FindManySsoEmailTemplateResponse {
    /**
     * 
     * @type {Array<SsoEmailTemplateDto>}
     * @memberof FindManySsoEmailTemplateResponse
     */
    'ssoEmailTemplates': Array<SsoEmailTemplateDto>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManySsoEmailTemplateResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface FindManySsoPublicTenantResponse
 */
export interface FindManySsoPublicTenantResponse {
    /**
     * 
     * @type {Array<SsoPublicTenantDto>}
     * @memberof FindManySsoPublicTenantResponse
     */
    'ssoPublicTenants': Array<SsoPublicTenantDto>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManySsoPublicTenantResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface FindManySsoRefreshSessionResponse
 */
export interface FindManySsoRefreshSessionResponse {
    /**
     * 
     * @type {Array<SsoRefreshSessionDto>}
     * @memberof FindManySsoRefreshSessionResponse
     */
    'ssoRefreshSessions': Array<SsoRefreshSessionDto>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManySsoRefreshSessionResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface FindManySsoRoleResponse
 */
export interface FindManySsoRoleResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof FindManySsoRoleResponse
     */
    'userAvailableRoles': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FindManySsoRoleResponse
     */
    'userDefaultRoles': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FindManySsoRoleResponse
     */
    'adminDefaultRoles': Array<string>;
}
/**
 * 
 * @export
 * @interface FindManySsoTenantResponse
 */
export interface FindManySsoTenantResponse {
    /**
     * 
     * @type {Array<SsoTenantDto>}
     * @memberof FindManySsoTenantResponse
     */
    'ssoTenants': Array<SsoTenantDto>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManySsoTenantResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface FindManySsoUserResponse
 */
export interface FindManySsoUserResponse {
    /**
     * 
     * @type {Array<SsoUserDto>}
     * @memberof FindManySsoUserResponse
     */
    'ssoUsers': Array<SsoUserDto>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManySsoUserResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface FindManyWebhookLogResponse
 */
export interface FindManyWebhookLogResponse {
    /**
     * 
     * @type {Array<WebhookLog>}
     * @memberof FindManyWebhookLogResponse
     */
    'webhookLogs': Array<WebhookLog>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManyWebhookLogResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface FindManyWebhookResponse
 */
export interface FindManyWebhookResponse {
    /**
     * 
     * @type {Array<Webhook>}
     * @memberof FindManyWebhookResponse
     */
    'webhooks': Array<Webhook>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManyWebhookResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface ForgotPasswordArgs
 */
export interface ForgotPasswordArgs {
    /**
     * 
     * @type {string}
     * @memberof ForgotPasswordArgs
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof ForgotPasswordArgs
     */
    'redirectUri'?: string;
}
/**
 * 
 * @export
 * @interface NotificationsControllerFindMany400Response
 */
export interface NotificationsControllerFindMany400Response {
    /**
     * Validation error (VALIDATION-000)
     * @type {string}
     * @memberof NotificationsControllerFindMany400Response
     */
    'message': string;
    /**
     * 
     * @type {ValidationErrorEnum}
     * @memberof NotificationsControllerFindMany400Response
     */
    'code': ValidationErrorEnum;
    /**
     * 
     * @type {Array<ValidationErrorMetadata>}
     * @memberof NotificationsControllerFindMany400Response
     */
    'metadata'?: Array<ValidationErrorMetadata>;
}


/**
 * 
 * @export
 * @interface NotificationsEntities
 */
export interface NotificationsEntities {
    /**
     * 
     * @type {NotificationsUserScalarFieldEnum}
     * @memberof NotificationsEntities
     */
    'NotificationsUser': NotificationsUserScalarFieldEnum;
    /**
     * 
     * @type {NotificationsEventScalarFieldEnum}
     * @memberof NotificationsEntities
     */
    'NotificationsEvent': NotificationsEventScalarFieldEnum;
}


/**
 * 
 * @export
 * @interface NotificationsError
 */
export interface NotificationsError {
    /**
     * Notifications error (NOTIFICATIONS-000), Tenant ID not set (NOTIFICATIONS-001), User ID not set (NOTIFICATIONS-002), Forbidden (NOTIFICATIONS-003)
     * @type {string}
     * @memberof NotificationsError
     */
    'message': string;
    /**
     * 
     * @type {NotificationsErrorEnum}
     * @memberof NotificationsError
     */
    'code': NotificationsErrorEnum;
    /**
     * 
     * @type {object}
     * @memberof NotificationsError
     */
    'metadata'?: object;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const NotificationsErrorEnum = {
    Notifications000: 'NOTIFICATIONS-000',
    Notifications001: 'NOTIFICATIONS-001',
    Notifications002: 'NOTIFICATIONS-002',
    Notifications003: 'NOTIFICATIONS-003'
} as const;

export type NotificationsErrorEnum = typeof NotificationsErrorEnum[keyof typeof NotificationsErrorEnum];


/**
 * 
 * @export
 * @interface NotificationsEvent
 */
export interface NotificationsEvent {
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'operationName': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'subject': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'html': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'text': string | null;
    /**
     * 
     * @type {number}
     * @memberof NotificationsEvent
     */
    'attempt': number;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationsEvent
     */
    'used': boolean;
    /**
     * 
     * @type {object}
     * @memberof NotificationsEvent
     */
    'error': object | null;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'senderUserId': string | null;
    /**
     * 
     * @type {object}
     * @memberof NotificationsEvent
     */
    'senderData': object | null;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'recipientGroupId': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'recipientUserId': string;
    /**
     * 
     * @type {object}
     * @memberof NotificationsEvent
     */
    'recipientData': object | null;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'externalTenantId': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'updatedAt': string;
    /**
     * 
     * @type {NotificationsUser}
     * @memberof NotificationsEvent
     */
    'NotificationsUser_NotificationsEvent_recipientUserIdToNotificationsUser'?: NotificationsUser;
    /**
     * 
     * @type {NotificationsUser}
     * @memberof NotificationsEvent
     */
    'NotificationsUser_NotificationsEvent_senderUserIdToNotificationsUser'?: NotificationsUser | null;
}
/**
 * 
 * @export
 * @interface NotificationsEventDto
 */
export interface NotificationsEventDto {
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'operationName': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'subject': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'html': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'text': string | null;
    /**
     * 
     * @type {number}
     * @memberof NotificationsEventDto
     */
    'attempt': number;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationsEventDto
     */
    'used': boolean;
    /**
     * 
     * @type {object}
     * @memberof NotificationsEventDto
     */
    'error': object | null;
    /**
     * 
     * @type {object}
     * @memberof NotificationsEventDto
     */
    'senderData': object | null;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'recipientGroupId': string;
    /**
     * 
     * @type {object}
     * @memberof NotificationsEventDto
     */
    'recipientData': object | null;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'externalTenantId': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const NotificationsEventScalarFieldEnum = {
    Id: 'id',
    Type: 'type',
    OperationName: 'operationName',
    Subject: 'subject',
    Html: 'html',
    Text: 'text',
    Attempt: 'attempt',
    Used: 'used',
    Error: 'error',
    SenderUserId: 'senderUserId',
    SenderData: 'senderData',
    RecipientGroupId: 'recipientGroupId',
    RecipientUserId: 'recipientUserId',
    RecipientData: 'recipientData',
    ExternalTenantId: 'externalTenantId',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;

export type NotificationsEventScalarFieldEnum = typeof NotificationsEventScalarFieldEnum[keyof typeof NotificationsEventScalarFieldEnum];


/**
 * 
 * @export
 * @interface NotificationsUser
 */
export interface NotificationsUser {
    /**
     * 
     * @type {string}
     * @memberof NotificationsUser
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsUser
     */
    'externalTenantId': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsUser
     */
    'externalUserId': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsUser
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsUser
     */
    'updatedAt': string;
    /**
     * 
     * @type {Array<NotificationsEvent>}
     * @memberof NotificationsUser
     */
    'NotificationsEvent_NotificationsEvent_recipientUserIdToNotificationsUser'?: Array<NotificationsEvent>;
    /**
     * 
     * @type {Array<NotificationsEvent>}
     * @memberof NotificationsUser
     */
    'NotificationsEvent_NotificationsEvent_senderUserIdToNotificationsUser'?: Array<NotificationsEvent>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const NotificationsUserScalarFieldEnum = {
    Id: 'id',
    ExternalTenantId: 'externalTenantId',
    ExternalUserId: 'externalUserId',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;

export type NotificationsUserScalarFieldEnum = typeof NotificationsUserScalarFieldEnum[keyof typeof NotificationsUserScalarFieldEnum];


/**
 * 
 * @export
 * @interface OAuthProvider
 */
export interface OAuthProvider {
    /**
     * 
     * @type {string}
     * @memberof OAuthProvider
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OAuthProvider
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof OAuthProvider
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof OAuthProvider
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof OAuthProvider
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof OAuthProvider
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface RefreshTokensResponse
 */
export interface RefreshTokensResponse {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokensResponse
     */
    'fingerprint': string;
    /**
     * 
     * @type {string}
     * @memberof RefreshTokensResponse
     */
    'refreshToken'?: string;
}
/**
 * 
 * @export
 * @interface SendInvitationLinksArgs
 */
export interface SendInvitationLinksArgs {
    /**
     * 
     * @type {string}
     * @memberof SendInvitationLinksArgs
     */
    'emails': string;
}
/**
 * 
 * @export
 * @interface SignInArgs
 */
export interface SignInArgs {
    /**
     * 
     * @type {string}
     * @memberof SignInArgs
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SignInArgs
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof SignInArgs
     */
    'fingerprint': string;
}
/**
 * 
 * @export
 * @interface SignOutArgs
 */
export interface SignOutArgs {
    /**
     * 
     * @type {string}
     * @memberof SignOutArgs
     */
    'refreshToken'?: string;
}
/**
 * 
 * @export
 * @interface SignUpArgs
 */
export interface SignUpArgs {
    /**
     * 
     * @type {string}
     * @memberof SignUpArgs
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpArgs
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpArgs
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpArgs
     */
    'confirmPassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpArgs
     */
    'fingerprint': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpArgs
     */
    'redirectUri'?: string;
    /**
     * 
     * @type {object}
     * @memberof SignUpArgs
     */
    'appData'?: object;
}
/**
 * 
 * @export
 * @interface SsoControllerSignIn400Response
 */
export interface SsoControllerSignIn400Response {
    /**
     * Validation error (VALIDATION-000)
     * @type {string}
     * @memberof SsoControllerSignIn400Response
     */
    'message': string;
    /**
     * 
     * @type {ValidationErrorEnum}
     * @memberof SsoControllerSignIn400Response
     */
    'code': ValidationErrorEnum;
    /**
     * 
     * @type {Array<ValidationErrorMetadata>}
     * @memberof SsoControllerSignIn400Response
     */
    'metadata'?: Array<ValidationErrorMetadata>;
}


/**
 * 
 * @export
 * @interface SsoEmailTemplate
 */
export interface SsoEmailTemplate {
    /**
     * 
     * @type {string}
     * @memberof SsoEmailTemplate
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SsoEmailTemplate
     */
    'subject': string;
    /**
     * 
     * @type {object}
     * @memberof SsoEmailTemplate
     */
    'subjectLocale': object | null;
    /**
     * 
     * @type {string}
     * @memberof SsoEmailTemplate
     */
    'text': string;
    /**
     * 
     * @type {object}
     * @memberof SsoEmailTemplate
     */
    'textLocale': object | null;
    /**
     * 
     * @type {string}
     * @memberof SsoEmailTemplate
     */
    'html': string;
    /**
     * 
     * @type {object}
     * @memberof SsoEmailTemplate
     */
    'htmlLocale': object | null;
    /**
     * 
     * @type {string}
     * @memberof SsoEmailTemplate
     */
    'operationName': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoEmailTemplate
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof SsoEmailTemplate
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SsoEmailTemplate
     */
    'updatedAt': string;
    /**
     * 
     * @type {SsoTenant}
     * @memberof SsoEmailTemplate
     */
    'SsoTenant'?: SsoTenant;
}
/**
 * 
 * @export
 * @interface SsoEmailTemplateDto
 */
export interface SsoEmailTemplateDto {
    /**
     * 
     * @type {string}
     * @memberof SsoEmailTemplateDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SsoEmailTemplateDto
     */
    'subject': string;
    /**
     * 
     * @type {object}
     * @memberof SsoEmailTemplateDto
     */
    'subjectLocale': object | null;
    /**
     * 
     * @type {string}
     * @memberof SsoEmailTemplateDto
     */
    'text': string;
    /**
     * 
     * @type {object}
     * @memberof SsoEmailTemplateDto
     */
    'textLocale': object | null;
    /**
     * 
     * @type {string}
     * @memberof SsoEmailTemplateDto
     */
    'html': string;
    /**
     * 
     * @type {object}
     * @memberof SsoEmailTemplateDto
     */
    'htmlLocale': object | null;
    /**
     * 
     * @type {string}
     * @memberof SsoEmailTemplateDto
     */
    'operationName': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoEmailTemplateDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SsoEmailTemplateDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SsoEmailTemplateScalarFieldEnum = {
    Id: 'id',
    Subject: 'subject',
    SubjectLocale: 'subjectLocale',
    Text: 'text',
    TextLocale: 'textLocale',
    Html: 'html',
    HtmlLocale: 'htmlLocale',
    OperationName: 'operationName',
    TenantId: 'tenantId',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;

export type SsoEmailTemplateScalarFieldEnum = typeof SsoEmailTemplateScalarFieldEnum[keyof typeof SsoEmailTemplateScalarFieldEnum];


/**
 * 
 * @export
 * @interface SsoEntities
 */
export interface SsoEntities {
    /**
     * 
     * @type {SsoUserScalarFieldEnum}
     * @memberof SsoEntities
     */
    'SsoUser': SsoUserScalarFieldEnum;
    /**
     * 
     * @type {SsoRefreshSessionScalarFieldEnum}
     * @memberof SsoEntities
     */
    'SsoRefreshSession': SsoRefreshSessionScalarFieldEnum;
    /**
     * 
     * @type {SsoEmailTemplateScalarFieldEnum}
     * @memberof SsoEntities
     */
    'SsoEmailTemplate': SsoEmailTemplateScalarFieldEnum;
    /**
     * 
     * @type {SsoOAuthProviderScalarFieldEnum}
     * @memberof SsoEntities
     */
    'SsoOAuthProvider': SsoOAuthProviderScalarFieldEnum;
    /**
     * 
     * @type {SsoOAuthProviderSettingsScalarFieldEnum}
     * @memberof SsoEntities
     */
    'SsoOAuthProviderSettings': SsoOAuthProviderSettingsScalarFieldEnum;
    /**
     * 
     * @type {SsoOAuthTokenScalarFieldEnum}
     * @memberof SsoEntities
     */
    'SsoOAuthToken': SsoOAuthTokenScalarFieldEnum;
    /**
     * 
     * @type {SsoTenantScalarFieldEnum}
     * @memberof SsoEntities
     */
    'SsoTenant': SsoTenantScalarFieldEnum;
    /**
     * 
     * @type {SsoRole}
     * @memberof SsoEntities
     */
    'role': SsoRole;
}


/**
 * 
 * @export
 * @interface SsoError
 */
export interface SsoError {
    /**
     * Sso error (SSO-000), User not found (SSO-001), Wrong password (SSO-002), User is exists (SSO-003), Wrong activate email code (SSO-004), Activate email not processed (SSO-005), Activate email processed (SSO-006), Refresh token not provided (SSO-007), Session expired (SSO-008), Invalid refresh session (SSO-009), Access token expired (SSO-010), User is exists (SSO-011), Email not verified (SSO-012), Forbidden (SSO-013), Wrong old password (SSO-014), Non-existent role specified (SSO-015), Bad access token (SSO-016), Your session has been blocked (SSO-017), Verification code not found (SSO-018)
     * @type {string}
     * @memberof SsoError
     */
    'message': string;
    /**
     * 
     * @type {SsoErrorEnum}
     * @memberof SsoError
     */
    'code': SsoErrorEnum;
    /**
     * 
     * @type {object}
     * @memberof SsoError
     */
    'metadata'?: object;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const SsoErrorEnum = {
    Sso000: 'SSO-000',
    Sso001: 'SSO-001',
    Sso002: 'SSO-002',
    Sso003: 'SSO-003',
    Sso004: 'SSO-004',
    Sso005: 'SSO-005',
    Sso006: 'SSO-006',
    Sso007: 'SSO-007',
    Sso008: 'SSO-008',
    Sso009: 'SSO-009',
    Sso010: 'SSO-010',
    Sso011: 'SSO-011',
    Sso012: 'SSO-012',
    Sso013: 'SSO-013',
    Sso014: 'SSO-014',
    Sso015: 'SSO-015',
    Sso016: 'SSO-016',
    Sso017: 'SSO-017',
    Sso018: 'SSO-018'
} as const;

export type SsoErrorEnum = typeof SsoErrorEnum[keyof typeof SsoErrorEnum];


/**
 * 
 * @export
 * @interface SsoOAuthProvider
 */
export interface SsoOAuthProvider {
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthProvider
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthProvider
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof SsoOAuthProvider
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthProvider
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthProvider
     */
    'updatedAt': string;
    /**
     * 
     * @type {Array<SsoOAuthProviderSettings>}
     * @memberof SsoOAuthProvider
     */
    'SsoOAuthProviderSettings'?: Array<SsoOAuthProviderSettings>;
    /**
     * 
     * @type {Array<SsoOAuthToken>}
     * @memberof SsoOAuthProvider
     */
    'SsoOAuthToken'?: Array<SsoOAuthToken>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SsoOAuthProviderScalarFieldEnum = {
    Id: 'id',
    Name: 'name',
    Enabled: 'enabled',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;

export type SsoOAuthProviderScalarFieldEnum = typeof SsoOAuthProviderScalarFieldEnum[keyof typeof SsoOAuthProviderScalarFieldEnum];


/**
 * 
 * @export
 * @interface SsoOAuthProviderSettings
 */
export interface SsoOAuthProviderSettings {
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthProviderSettings
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthProviderSettings
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthProviderSettings
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthProviderSettings
     */
    'providerId': string;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthProviderSettings
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthProviderSettings
     */
    'updatedAt': string;
    /**
     * 
     * @type {SsoOAuthProvider}
     * @memberof SsoOAuthProviderSettings
     */
    'SsoOAuthProvider'?: SsoOAuthProvider;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SsoOAuthProviderSettingsScalarFieldEnum = {
    Id: 'id',
    Name: 'name',
    Value: 'value',
    ProviderId: 'providerId',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;

export type SsoOAuthProviderSettingsScalarFieldEnum = typeof SsoOAuthProviderSettingsScalarFieldEnum[keyof typeof SsoOAuthProviderSettingsScalarFieldEnum];


/**
 * 
 * @export
 * @interface SsoOAuthToken
 */
export interface SsoOAuthToken {
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthToken
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthToken
     */
    'grantedAt': string;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthToken
     */
    'expiresAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthToken
     */
    'tokenType': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthToken
     */
    'scope': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthToken
     */
    'verificationCode': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthToken
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthToken
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthToken
     */
    'providerId': string;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthToken
     */
    'providerUserId': string;
    /**
     * 
     * @type {object}
     * @memberof SsoOAuthToken
     */
    'providerUserData': object | null;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthToken
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthToken
     */
    'updatedAt': string;
    /**
     * 
     * @type {SsoOAuthProvider}
     * @memberof SsoOAuthToken
     */
    'SsoOAuthProvider'?: SsoOAuthProvider;
    /**
     * 
     * @type {SsoTenant}
     * @memberof SsoOAuthToken
     */
    'SsoTenant'?: SsoTenant;
    /**
     * 
     * @type {SsoUser}
     * @memberof SsoOAuthToken
     */
    'SsoUser'?: SsoUser;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SsoOAuthTokenScalarFieldEnum = {
    Id: 'id',
    GrantedAt: 'grantedAt',
    AccessToken: 'accessToken',
    RefreshToken: 'refreshToken',
    ExpiresAt: 'expiresAt',
    TokenType: 'tokenType',
    Scope: 'scope',
    VerificationCode: 'verificationCode',
    UserId: 'userId',
    TenantId: 'tenantId',
    ProviderId: 'providerId',
    ProviderUserId: 'providerUserId',
    ProviderUserData: 'providerUserData',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;

export type SsoOAuthTokenScalarFieldEnum = typeof SsoOAuthTokenScalarFieldEnum[keyof typeof SsoOAuthTokenScalarFieldEnum];


/**
 * 
 * @export
 * @interface SsoOAuthVerificationArgs
 */
export interface SsoOAuthVerificationArgs {
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthVerificationArgs
     */
    'verificationCode': string;
    /**
     * 
     * @type {string}
     * @memberof SsoOAuthVerificationArgs
     */
    'fingerprint': string;
}
/**
 * 
 * @export
 * @interface SsoPublicTenantDto
 */
export interface SsoPublicTenantDto {
    /**
     * 
     * @type {string}
     * @memberof SsoPublicTenantDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SsoPublicTenantDto
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof SsoPublicTenantDto
     */
    'name': string;
    /**
     * 
     * @type {object}
     * @memberof SsoPublicTenantDto
     */
    'nameLocale': object | null;
    /**
     * 
     * @type {string}
     * @memberof SsoPublicTenantDto
     */
    'clientId': string;
    /**
     * 
     * @type {boolean}
     * @memberof SsoPublicTenantDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof SsoPublicTenantDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SsoPublicTenantDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface SsoRefreshSession
 */
export interface SsoRefreshSession {
    /**
     * 
     * @type {string}
     * @memberof SsoRefreshSession
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SsoRefreshSession
     */
    'userAgent': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoRefreshSession
     */
    'userIp': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoRefreshSession
     */
    'expiresAt': string | null;
    /**
     * 
     * @type {object}
     * @memberof SsoRefreshSession
     */
    'userData': object | null;
    /**
     * 
     * @type {boolean}
     * @memberof SsoRefreshSession
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof SsoRefreshSession
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof SsoRefreshSession
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof SsoRefreshSession
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SsoRefreshSession
     */
    'updatedAt': string;
    /**
     * 
     * @type {SsoTenant}
     * @memberof SsoRefreshSession
     */
    'SsoTenant'?: SsoTenant;
    /**
     * 
     * @type {SsoUser}
     * @memberof SsoRefreshSession
     */
    'SsoUser'?: SsoUser;
}
/**
 * 
 * @export
 * @interface SsoRefreshSessionDto
 */
export interface SsoRefreshSessionDto {
    /**
     * 
     * @type {string}
     * @memberof SsoRefreshSessionDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SsoRefreshSessionDto
     */
    'userAgent': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoRefreshSessionDto
     */
    'userIp': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoRefreshSessionDto
     */
    'expiresAt': string | null;
    /**
     * 
     * @type {object}
     * @memberof SsoRefreshSessionDto
     */
    'userData': object | null;
    /**
     * 
     * @type {boolean}
     * @memberof SsoRefreshSessionDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof SsoRefreshSessionDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SsoRefreshSessionDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SsoRefreshSessionScalarFieldEnum = {
    Id: 'id',
    RefreshToken: 'refreshToken',
    UserAgent: 'userAgent',
    Fingerprint: 'fingerprint',
    UserIp: 'userIp',
    ExpiresAt: 'expiresAt',
    UserData: 'userData',
    Enabled: 'enabled',
    UserId: 'userId',
    TenantId: 'tenantId',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;

export type SsoRefreshSessionScalarFieldEnum = typeof SsoRefreshSessionScalarFieldEnum[keyof typeof SsoRefreshSessionScalarFieldEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const SsoRole = {
    Admin: 'admin',
    Manager: 'manager',
    User: 'user'
} as const;

export type SsoRole = typeof SsoRole[keyof typeof SsoRole];


/**
 * 
 * @export
 * @interface SsoTenant
 */
export interface SsoTenant {
    /**
     * 
     * @type {string}
     * @memberof SsoTenant
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SsoTenant
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof SsoTenant
     */
    'name': string;
    /**
     * 
     * @type {object}
     * @memberof SsoTenant
     */
    'nameLocale': object | null;
    /**
     * 
     * @type {string}
     * @memberof SsoTenant
     */
    'clientId': string;
    /**
     * 
     * @type {string}
     * @memberof SsoTenant
     */
    'clientSecret': string;
    /**
     * 
     * @type {boolean}
     * @memberof SsoTenant
     */
    'enabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SsoTenant
     */
    'public': boolean;
    /**
     * 
     * @type {string}
     * @memberof SsoTenant
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SsoTenant
     */
    'updatedAt': string;
    /**
     * 
     * @type {Array<SsoEmailTemplate>}
     * @memberof SsoTenant
     */
    'SsoEmailTemplate'?: Array<SsoEmailTemplate>;
    /**
     * 
     * @type {Array<SsoOAuthToken>}
     * @memberof SsoTenant
     */
    'SsoOAuthToken'?: Array<SsoOAuthToken>;
    /**
     * 
     * @type {Array<SsoRefreshSession>}
     * @memberof SsoTenant
     */
    'SsoRefreshSession'?: Array<SsoRefreshSession>;
    /**
     * 
     * @type {Array<SsoUser>}
     * @memberof SsoTenant
     */
    'SsoUser'?: Array<SsoUser>;
}
/**
 * 
 * @export
 * @interface SsoTenantDto
 */
export interface SsoTenantDto {
    /**
     * 
     * @type {string}
     * @memberof SsoTenantDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SsoTenantDto
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof SsoTenantDto
     */
    'name': string;
    /**
     * 
     * @type {object}
     * @memberof SsoTenantDto
     */
    'nameLocale': object | null;
    /**
     * 
     * @type {string}
     * @memberof SsoTenantDto
     */
    'clientId': string;
    /**
     * 
     * @type {string}
     * @memberof SsoTenantDto
     */
    'clientSecret': string;
    /**
     * 
     * @type {boolean}
     * @memberof SsoTenantDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SsoTenantDto
     */
    'public': boolean;
    /**
     * 
     * @type {string}
     * @memberof SsoTenantDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SsoTenantDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SsoTenantScalarFieldEnum = {
    Id: 'id',
    Slug: 'slug',
    Name: 'name',
    NameLocale: 'nameLocale',
    ClientId: 'clientId',
    ClientSecret: 'clientSecret',
    Enabled: 'enabled',
    Public: 'public',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;

export type SsoTenantScalarFieldEnum = typeof SsoTenantScalarFieldEnum[keyof typeof SsoTenantScalarFieldEnum];


/**
 * 
 * @export
 * @interface SsoUser
 */
export interface SsoUser {
    /**
     * 
     * @type {string}
     * @memberof SsoUser
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SsoUser
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SsoUser
     */
    'phone': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUser
     */
    'username': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUser
     */
    'roles': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUser
     */
    'firstname': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUser
     */
    'lastname': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUser
     */
    'gender': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUser
     */
    'birthdate': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUser
     */
    'picture': string | null;
    /**
     * 
     * @type {object}
     * @memberof SsoUser
     */
    'appData': object | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUser
     */
    'revokedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUser
     */
    'emailVerifiedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUser
     */
    'phoneVerifiedAt': string | null;
    /**
     * 
     * @type {number}
     * @memberof SsoUser
     */
    'timezone': number | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUser
     */
    'lang': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUser
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof SsoUser
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SsoUser
     */
    'updatedAt': string;
    /**
     * 
     * @type {Array<SsoOAuthToken>}
     * @memberof SsoUser
     */
    'SsoOAuthToken'?: Array<SsoOAuthToken>;
    /**
     * 
     * @type {Array<SsoRefreshSession>}
     * @memberof SsoUser
     */
    'SsoRefreshSession'?: Array<SsoRefreshSession>;
    /**
     * 
     * @type {SsoTenant}
     * @memberof SsoUser
     */
    'SsoTenant'?: SsoTenant;
}
/**
 * 
 * @export
 * @interface SsoUserDto
 */
export interface SsoUserDto {
    /**
     * 
     * @type {string}
     * @memberof SsoUserDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SsoUserDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SsoUserDto
     */
    'phone': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUserDto
     */
    'username': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUserDto
     */
    'roles': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUserDto
     */
    'firstname': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUserDto
     */
    'lastname': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUserDto
     */
    'gender': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUserDto
     */
    'birthdate': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUserDto
     */
    'picture': string | null;
    /**
     * 
     * @type {object}
     * @memberof SsoUserDto
     */
    'appData': object | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUserDto
     */
    'revokedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUserDto
     */
    'emailVerifiedAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUserDto
     */
    'phoneVerifiedAt': string | null;
    /**
     * 
     * @type {number}
     * @memberof SsoUserDto
     */
    'timezone': number | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUserDto
     */
    'lang': string | null;
    /**
     * 
     * @type {string}
     * @memberof SsoUserDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SsoUserDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SsoUserScalarFieldEnum = {
    Id: 'id',
    Email: 'email',
    Phone: 'phone',
    Username: 'username',
    Password: 'password',
    Roles: 'roles',
    Firstname: 'firstname',
    Lastname: 'lastname',
    Gender: 'gender',
    Birthdate: 'birthdate',
    Picture: 'picture',
    AppData: 'appData',
    RevokedAt: 'revokedAt',
    EmailVerifiedAt: 'emailVerifiedAt',
    PhoneVerifiedAt: 'phoneVerifiedAt',
    Timezone: 'timezone',
    Lang: 'lang',
    TenantId: 'tenantId',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;

export type SsoUserScalarFieldEnum = typeof SsoUserScalarFieldEnum[keyof typeof SsoUserScalarFieldEnum];


/**
 * 
 * @export
 * @interface StatusResponse
 */
export interface StatusResponse {
    /**
     * 
     * @type {string}
     * @memberof StatusResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface TerminusHealthCheckControllerCheck200Response
 */
export interface TerminusHealthCheckControllerCheck200Response {
    /**
     * 
     * @type {string}
     * @memberof TerminusHealthCheckControllerCheck200Response
     */
    'status'?: string;
    /**
     * 
     * @type {{ [key: string]: TerminusHealthCheckControllerCheck200ResponseInfoValue; }}
     * @memberof TerminusHealthCheckControllerCheck200Response
     */
    'info'?: { [key: string]: TerminusHealthCheckControllerCheck200ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: TerminusHealthCheckControllerCheck200ResponseInfoValue; }}
     * @memberof TerminusHealthCheckControllerCheck200Response
     */
    'error'?: { [key: string]: TerminusHealthCheckControllerCheck200ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: TerminusHealthCheckControllerCheck200ResponseInfoValue; }}
     * @memberof TerminusHealthCheckControllerCheck200Response
     */
    'details'?: { [key: string]: TerminusHealthCheckControllerCheck200ResponseInfoValue; };
}
/**
 * 
 * @export
 * @interface TerminusHealthCheckControllerCheck200ResponseInfoValue
 */
export interface TerminusHealthCheckControllerCheck200ResponseInfoValue {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof TerminusHealthCheckControllerCheck200ResponseInfoValue
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface TerminusHealthCheckControllerCheck503Response
 */
export interface TerminusHealthCheckControllerCheck503Response {
    /**
     * 
     * @type {string}
     * @memberof TerminusHealthCheckControllerCheck503Response
     */
    'status'?: string;
    /**
     * 
     * @type {{ [key: string]: TerminusHealthCheckControllerCheck200ResponseInfoValue; }}
     * @memberof TerminusHealthCheckControllerCheck503Response
     */
    'info'?: { [key: string]: TerminusHealthCheckControllerCheck200ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: TerminusHealthCheckControllerCheck200ResponseInfoValue; }}
     * @memberof TerminusHealthCheckControllerCheck503Response
     */
    'error'?: { [key: string]: TerminusHealthCheckControllerCheck200ResponseInfoValue; } | null;
    /**
     * 
     * @type {{ [key: string]: TerminusHealthCheckControllerCheck200ResponseInfoValue; }}
     * @memberof TerminusHealthCheckControllerCheck503Response
     */
    'details'?: { [key: string]: TerminusHealthCheckControllerCheck200ResponseInfoValue; };
}
/**
 * 
 * @export
 * @interface TokensResponse
 */
export interface TokensResponse {
    /**
     * 
     * @type {string}
     * @memberof TokensResponse
     */
    'accessToken': string;
    /**
     * 
     * @type {string}
     * @memberof TokensResponse
     */
    'refreshToken': string;
    /**
     * 
     * @type {SsoUser}
     * @memberof TokensResponse
     */
    'user': SsoUser;
}
/**
 * 
 * @export
 * @interface UpdateNotificationsEventDto
 */
export interface UpdateNotificationsEventDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationsEventDto
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationsEventDto
     */
    'operationName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationsEventDto
     */
    'subject'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationsEventDto
     */
    'html'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationsEventDto
     */
    'text'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateNotificationsEventDto
     */
    'attempt'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateNotificationsEventDto
     */
    'used'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof UpdateNotificationsEventDto
     */
    'error'?: object | null;
    /**
     * 
     * @type {object}
     * @memberof UpdateNotificationsEventDto
     */
    'senderData'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationsEventDto
     */
    'recipientGroupId'?: string;
    /**
     * 
     * @type {object}
     * @memberof UpdateNotificationsEventDto
     */
    'recipientData'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationsEventDto
     */
    'externalTenantId'?: string;
}
/**
 * 
 * @export
 * @interface UpdateProfileArgs
 */
export interface UpdateProfileArgs {
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileArgs
     */
    'firstname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileArgs
     */
    'lastname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileArgs
     */
    'gender'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileArgs
     */
    'birthdate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileArgs
     */
    'picture'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateProfileArgs
     */
    'timezone'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileArgs
     */
    'lang'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileArgs
     */
    'oldPassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileArgs
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileArgs
     */
    'confirmPassword'?: string;
}
/**
 * 
 * @export
 * @interface UpdateSsoEmailTemplateDto
 */
export interface UpdateSsoEmailTemplateDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoEmailTemplateDto
     */
    'subject'?: string;
    /**
     * 
     * @type {object}
     * @memberof UpdateSsoEmailTemplateDto
     */
    'subjectLocale'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoEmailTemplateDto
     */
    'text'?: string;
    /**
     * 
     * @type {object}
     * @memberof UpdateSsoEmailTemplateDto
     */
    'textLocale'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoEmailTemplateDto
     */
    'html'?: string;
    /**
     * 
     * @type {object}
     * @memberof UpdateSsoEmailTemplateDto
     */
    'htmlLocale'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoEmailTemplateDto
     */
    'operationName'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateSsoRefreshSessionDto
 */
export interface UpdateSsoRefreshSessionDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoRefreshSessionDto
     */
    'refreshToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoRefreshSessionDto
     */
    'userAgent'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoRefreshSessionDto
     */
    'fingerprint'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoRefreshSessionDto
     */
    'userIp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoRefreshSessionDto
     */
    'expiresAt'?: string | null;
    /**
     * 
     * @type {object}
     * @memberof UpdateSsoRefreshSessionDto
     */
    'userData'?: object | null;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateSsoRefreshSessionDto
     */
    'enabled'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateSsoTenantDto
 */
export interface UpdateSsoTenantDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoTenantDto
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoTenantDto
     */
    'name'?: string;
    /**
     * 
     * @type {object}
     * @memberof UpdateSsoTenantDto
     */
    'nameLocale'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoTenantDto
     */
    'clientId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoTenantDto
     */
    'clientSecret'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateSsoTenantDto
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateSsoTenantDto
     */
    'public'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateSsoUserDto
 */
export interface UpdateSsoUserDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoUserDto
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoUserDto
     */
    'phone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoUserDto
     */
    'username'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoUserDto
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoUserDto
     */
    'roles'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoUserDto
     */
    'firstname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoUserDto
     */
    'lastname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoUserDto
     */
    'gender'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoUserDto
     */
    'birthdate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoUserDto
     */
    'picture'?: string | null;
    /**
     * 
     * @type {object}
     * @memberof UpdateSsoUserDto
     */
    'appData'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoUserDto
     */
    'revokedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoUserDto
     */
    'emailVerifiedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoUserDto
     */
    'phoneVerifiedAt'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateSsoUserDto
     */
    'timezone'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoUserDto
     */
    'lang'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateWebhookDto
 */
export interface UpdateWebhookDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateWebhookDto
     */
    'eventName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWebhookDto
     */
    'endpoint'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateWebhookDto
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof UpdateWebhookDto
     */
    'headers'?: object | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateWebhookDto
     */
    'requestTimeout'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateWebhookDto
     */
    'workUntilDate'?: string | null;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * Validation error (VALIDATION-000)
     * @type {string}
     * @memberof ValidationError
     */
    'message': string;
    /**
     * 
     * @type {ValidationErrorEnum}
     * @memberof ValidationError
     */
    'code': ValidationErrorEnum;
    /**
     * 
     * @type {Array<ValidationErrorMetadata>}
     * @memberof ValidationError
     */
    'metadata'?: Array<ValidationErrorMetadata>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ValidationErrorEnum = {
    Validation000: 'VALIDATION-000'
} as const;

export type ValidationErrorEnum = typeof ValidationErrorEnum[keyof typeof ValidationErrorEnum];


/**
 * 
 * @export
 * @interface ValidationErrorMetadata
 */
export interface ValidationErrorMetadata {
    /**
     * 
     * @type {string}
     * @memberof ValidationErrorMetadata
     */
    'property': string;
    /**
     * 
     * @type {Array<ValidationErrorMetadataConstraint>}
     * @memberof ValidationErrorMetadata
     */
    'constraints': Array<ValidationErrorMetadataConstraint>;
    /**
     * 
     * @type {Array<ValidationErrorMetadata>}
     * @memberof ValidationErrorMetadata
     */
    'children'?: Array<ValidationErrorMetadata>;
}
/**
 * 
 * @export
 * @interface ValidationErrorMetadataConstraint
 */
export interface ValidationErrorMetadataConstraint {
    /**
     * 
     * @type {string}
     * @memberof ValidationErrorMetadataConstraint
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationErrorMetadataConstraint
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface Webhook
 */
export interface Webhook {
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'eventName': string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'endpoint': string;
    /**
     * 
     * @type {boolean}
     * @memberof Webhook
     */
    'enabled': boolean;
    /**
     * 
     * @type {object}
     * @memberof Webhook
     */
    'headers': object | null;
    /**
     * 
     * @type {number}
     * @memberof Webhook
     */
    'requestTimeout': number | null;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'externalTenantId': string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'createdBy': string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'updatedBy': string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'workUntilDate': string | null;
    /**
     * 
     * @type {WebhookUser}
     * @memberof Webhook
     */
    'WebhookUser_Webhook_createdByToWebhookUser'?: WebhookUser;
    /**
     * 
     * @type {WebhookUser}
     * @memberof Webhook
     */
    'WebhookUser_Webhook_updatedByToWebhookUser'?: WebhookUser;
    /**
     * 
     * @type {Array<WebhookLog>}
     * @memberof Webhook
     */
    'WebhookLog'?: Array<WebhookLog>;
}
/**
 * 
 * @export
 * @interface WebhookEntities
 */
export interface WebhookEntities {
    /**
     * 
     * @type {WebhookScalarFieldEnum}
     * @memberof WebhookEntities
     */
    'Webhook': WebhookScalarFieldEnum;
    /**
     * 
     * @type {WebhookLogScalarFieldEnum}
     * @memberof WebhookEntities
     */
    'WebhookLog': WebhookLogScalarFieldEnum;
    /**
     * 
     * @type {WebhookUserScalarFieldEnum}
     * @memberof WebhookEntities
     */
    'WebhookUser': WebhookUserScalarFieldEnum;
}


/**
 * 
 * @export
 * @interface WebhookError
 */
export interface WebhookError {
    /**
     * Webhook error (WEBHOOK-000), Tenant ID not set (WEBHOOK-003), User ID not set (WEBHOOK-002), Forbidden (WEBHOOK-001), User not found (WEBHOOK-004), Event not found (WEBHOOK-005)
     * @type {string}
     * @memberof WebhookError
     */
    'message': string;
    /**
     * 
     * @type {WebhookErrorEnum}
     * @memberof WebhookError
     */
    'code': WebhookErrorEnum;
    /**
     * 
     * @type {object}
     * @memberof WebhookError
     */
    'metadata'?: object;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const WebhookErrorEnum = {
    Webhook000: 'WEBHOOK-000',
    Webhook001: 'WEBHOOK-001',
    Webhook002: 'WEBHOOK-002',
    Webhook003: 'WEBHOOK-003',
    Webhook004: 'WEBHOOK-004',
    Webhook005: 'WEBHOOK-005'
} as const;

export type WebhookErrorEnum = typeof WebhookErrorEnum[keyof typeof WebhookErrorEnum];


/**
 * 
 * @export
 * @interface WebhookEvent
 */
export interface WebhookEvent {
    /**
     * 
     * @type {string}
     * @memberof WebhookEvent
     */
    'eventName': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookEvent
     */
    'description': string;
    /**
     * 
     * @type {object}
     * @memberof WebhookEvent
     */
    'example': object;
}
/**
 * 
 * @export
 * @interface WebhookLog
 */
export interface WebhookLog {
    /**
     * 
     * @type {string}
     * @memberof WebhookLog
     */
    'id': string;
    /**
     * 
     * @type {object}
     * @memberof WebhookLog
     */
    'request': object;
    /**
     * 
     * @type {string}
     * @memberof WebhookLog
     */
    'responseStatus': string;
    /**
     * 
     * @type {object}
     * @memberof WebhookLog
     */
    'response': object | null;
    /**
     * 
     * @type {WebhookStatus}
     * @memberof WebhookLog
     */
    'webhookStatus': WebhookStatus;
    /**
     * 
     * @type {string}
     * @memberof WebhookLog
     */
    'webhookId': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookLog
     */
    'externalTenantId': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookLog
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookLog
     */
    'updatedAt': string;
    /**
     * 
     * @type {Webhook}
     * @memberof WebhookLog
     */
    'Webhook'?: Webhook;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const WebhookLogScalarFieldEnum = {
    Id: 'id',
    Request: 'request',
    ResponseStatus: 'responseStatus',
    Response: 'response',
    WebhookStatus: 'webhookStatus',
    WebhookId: 'webhookId',
    ExternalTenantId: 'externalTenantId',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;

export type WebhookLogScalarFieldEnum = typeof WebhookLogScalarFieldEnum[keyof typeof WebhookLogScalarFieldEnum];


/**
 * 
 * @export
 * @interface WebhookLogsControllerFindManyLogs400Response
 */
export interface WebhookLogsControllerFindManyLogs400Response {
    /**
     * Validation error (VALIDATION-000)
     * @type {string}
     * @memberof WebhookLogsControllerFindManyLogs400Response
     */
    'message': string;
    /**
     * 
     * @type {ValidationErrorEnum}
     * @memberof WebhookLogsControllerFindManyLogs400Response
     */
    'code': ValidationErrorEnum;
    /**
     * 
     * @type {Array<ValidationErrorMetadata>}
     * @memberof WebhookLogsControllerFindManyLogs400Response
     */
    'metadata'?: Array<ValidationErrorMetadata>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const WebhookRole = {
    Admin: 'Admin',
    User: 'User'
} as const;

export type WebhookRole = typeof WebhookRole[keyof typeof WebhookRole];


/**
 * 
 * @export
 * @enum {string}
 */

export const WebhookScalarFieldEnum = {
    Id: 'id',
    EventName: 'eventName',
    Endpoint: 'endpoint',
    Enabled: 'enabled',
    Headers: 'headers',
    RequestTimeout: 'requestTimeout',
    ExternalTenantId: 'externalTenantId',
    CreatedBy: 'createdBy',
    UpdatedBy: 'updatedBy',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt',
    WorkUntilDate: 'workUntilDate'
} as const;

export type WebhookScalarFieldEnum = typeof WebhookScalarFieldEnum[keyof typeof WebhookScalarFieldEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const WebhookStatus = {
    Pending: 'Pending',
    Process: 'Process',
    Success: 'Success',
    Error: 'Error',
    Timeout: 'Timeout'
} as const;

export type WebhookStatus = typeof WebhookStatus[keyof typeof WebhookStatus];


/**
 * 
 * @export
 * @interface WebhookTestRequestResponse
 */
export interface WebhookTestRequestResponse {
    /**
     * 
     * @type {object}
     * @memberof WebhookTestRequestResponse
     */
    'request': object;
    /**
     * 
     * @type {string}
     * @memberof WebhookTestRequestResponse
     */
    'responseStatus': string;
    /**
     * 
     * @type {object}
     * @memberof WebhookTestRequestResponse
     */
    'response': object | null;
    /**
     * 
     * @type {WebhookStatus}
     * @memberof WebhookTestRequestResponse
     */
    'webhookStatus': WebhookStatus;
}


/**
 * 
 * @export
 * @interface WebhookUser
 */
export interface WebhookUser {
    /**
     * 
     * @type {string}
     * @memberof WebhookUser
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookUser
     */
    'externalTenantId': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookUser
     */
    'externalUserId': string;
    /**
     * 
     * @type {WebhookRole}
     * @memberof WebhookUser
     */
    'userRole': WebhookRole;
    /**
     * 
     * @type {string}
     * @memberof WebhookUser
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookUser
     */
    'updatedAt': string;
    /**
     * 
     * @type {Array<Webhook>}
     * @memberof WebhookUser
     */
    'Webhook_Webhook_createdByToWebhookUser'?: Array<Webhook>;
    /**
     * 
     * @type {Array<Webhook>}
     * @memberof WebhookUser
     */
    'Webhook_Webhook_updatedByToWebhookUser'?: Array<Webhook>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const WebhookUserScalarFieldEnum = {
    Id: 'id',
    ExternalTenantId: 'externalTenantId',
    ExternalUserId: 'externalUserId',
    UserRole: 'userRole',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;

export type WebhookUserScalarFieldEnum = typeof WebhookUserScalarFieldEnum[keyof typeof WebhookUserScalarFieldEnum];



/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} downloadUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesControllerDeleteFile: async (downloadUrl: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'downloadUrl' is not null or undefined
            assertParamExists('filesControllerDeleteFile', 'downloadUrl', downloadUrl)
            const localVarPath = `/api/files/delete-file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (downloadUrl !== undefined) {
                localVarQueryParameter['downloadUrl'] = downloadUrl;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} ext 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesControllerGetPresignedUrl: async (ext: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ext' is not null or undefined
            assertParamExists('filesControllerGetPresignedUrl', 'ext', ext)
            const localVarPath = `/api/files/get-presigned-url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ext !== undefined) {
                localVarQueryParameter['ext'] = ext;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} downloadUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesControllerDeleteFile(downloadUrl: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesControllerDeleteFile(downloadUrl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.filesControllerDeleteFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} ext 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesControllerGetPresignedUrl(ext: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilesPresignedUrls>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesControllerGetPresignedUrl(ext, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.filesControllerGetPresignedUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} downloadUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesControllerDeleteFile(downloadUrl: string, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.filesControllerDeleteFile(downloadUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} ext 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesControllerGetPresignedUrl(ext: string, options?: RawAxiosRequestConfig): AxiosPromise<FilesPresignedUrls> {
            return localVarFp.filesControllerGetPresignedUrl(ext, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     * 
     * @param {string} downloadUrl 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public filesControllerDeleteFile(downloadUrl: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).filesControllerDeleteFile(downloadUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} ext 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public filesControllerGetPresignedUrl(ext: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).filesControllerGetPresignedUrl(ext, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NotificationsApi - axios parameter creator
 * @export
 */
export const NotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsControllerFindMany: async (curPage?: number, perPage?: number, searchText?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('notificationsControllerFindOne', 'id', id)
            const localVarPath = `/api/notifications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateNotificationsEventDto} updateNotificationsEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsControllerUpdateOne: async (id: string, updateNotificationsEventDto: UpdateNotificationsEventDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('notificationsControllerUpdateOne', 'id', id)
            // verify required parameter 'updateNotificationsEventDto' is not null or undefined
            assertParamExists('notificationsControllerUpdateOne', 'updateNotificationsEventDto', updateNotificationsEventDto)
            const localVarPath = `/api/notifications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateNotificationsEventDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsApi - functional programming interface
 * @export
 */
export const NotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManyNotificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsControllerFindMany(curPage, perPage, searchText, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.notificationsControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationsEventDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.notificationsControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateNotificationsEventDto} updateNotificationsEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsControllerUpdateOne(id: string, updateNotificationsEventDto: UpdateNotificationsEventDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationsEventDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsControllerUpdateOne(id, updateNotificationsEventDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.notificationsControllerUpdateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NotificationsApi - factory interface
 * @export
 */
export const NotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationsApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManyNotificationResponse> {
            return localVarFp.notificationsControllerFindMany(curPage, perPage, searchText, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<NotificationsEventDto> {
            return localVarFp.notificationsControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateNotificationsEventDto} updateNotificationsEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsControllerUpdateOne(id: string, updateNotificationsEventDto: UpdateNotificationsEventDto, options?: RawAxiosRequestConfig): AxiosPromise<NotificationsEventDto> {
            return localVarFp.notificationsControllerUpdateOne(id, updateNotificationsEventDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
export class NotificationsApi extends BaseAPI {
    /**
     * 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notificationsControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsControllerFindMany(curPage, perPage, searchText, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notificationsControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateNotificationsEventDto} updateNotificationsEventDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notificationsControllerUpdateOne(id: string, updateNotificationsEventDto: UpdateNotificationsEventDto, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsControllerUpdateOne(id, updateNotificationsEventDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SsoApi - axios parameter creator
 * @export
 */
export const SsoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CompleteForgotPasswordArgs} completeForgotPasswordArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoControllerCompleteForgotPassword: async (completeForgotPasswordArgs: CompleteForgotPasswordArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'completeForgotPasswordArgs' is not null or undefined
            assertParamExists('ssoControllerCompleteForgotPassword', 'completeForgotPasswordArgs', completeForgotPasswordArgs)
            const localVarPath = `/api/sso/complete-forgot-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(completeForgotPasswordArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CompleteSignUpArgs} completeSignUpArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoControllerCompleteSignUp: async (completeSignUpArgs: CompleteSignUpArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'completeSignUpArgs' is not null or undefined
            assertParamExists('ssoControllerCompleteSignUp', 'completeSignUpArgs', completeSignUpArgs)
            const localVarPath = `/api/sso/complete-sign-up`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(completeSignUpArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ForgotPasswordArgs} forgotPasswordArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoControllerForgotPassword: async (forgotPasswordArgs: ForgotPasswordArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forgotPasswordArgs' is not null or undefined
            assertParamExists('ssoControllerForgotPassword', 'forgotPasswordArgs', forgotPasswordArgs)
            const localVarPath = `/api/sso/forgot-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgotPasswordArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoControllerProfile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RefreshTokensResponse} refreshTokensResponse 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoControllerRefreshTokens: async (refreshTokensResponse: RefreshTokensResponse, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokensResponse' is not null or undefined
            assertParamExists('ssoControllerRefreshTokens', 'refreshTokensResponse', refreshTokensResponse)
            const localVarPath = `/api/sso/refresh-tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokensResponse, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignInArgs} signInArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoControllerSignIn: async (signInArgs: SignInArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signInArgs' is not null or undefined
            assertParamExists('ssoControllerSignIn', 'signInArgs', signInArgs)
            const localVarPath = `/api/sso/sign-in`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signInArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignOutArgs} signOutArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoControllerSignOut: async (signOutArgs: SignOutArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signOutArgs' is not null or undefined
            assertParamExists('ssoControllerSignOut', 'signOutArgs', signOutArgs)
            const localVarPath = `/api/sso/sign-out`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signOutArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignUpArgs} signUpArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoControllerSignUp: async (signUpArgs: SignUpArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signUpArgs' is not null or undefined
            assertParamExists('ssoControllerSignUp', 'signUpArgs', signUpArgs)
            const localVarPath = `/api/sso/sign-up`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUpArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateProfileArgs} updateProfileArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoControllerUpdateProfile: async (updateProfileArgs: UpdateProfileArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateProfileArgs' is not null or undefined
            assertParamExists('ssoControllerUpdateProfile', 'updateProfileArgs', updateProfileArgs)
            const localVarPath = `/api/sso/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProfileArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoEmailTemplatesControllerFindMany: async (curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/email-templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenantId'] = tenantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoEmailTemplatesControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ssoEmailTemplatesControllerFindOne', 'id', id)
            const localVarPath = `/api/sso/email-templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateSsoEmailTemplateDto} updateSsoEmailTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoEmailTemplatesControllerUpdateOne: async (id: string, updateSsoEmailTemplateDto: UpdateSsoEmailTemplateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ssoEmailTemplatesControllerUpdateOne', 'id', id)
            // verify required parameter 'updateSsoEmailTemplateDto' is not null or undefined
            assertParamExists('ssoEmailTemplatesControllerUpdateOne', 'updateSsoEmailTemplateDto', updateSsoEmailTemplateDto)
            const localVarPath = `/api/sso/email-templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSsoEmailTemplateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} redirectUri 
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoGoogleOAuthControllerGoogleAuth: async (redirectUri: string, clientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'redirectUri' is not null or undefined
            assertParamExists('ssoGoogleOAuthControllerGoogleAuth', 'redirectUri', redirectUri)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('ssoGoogleOAuthControllerGoogleAuth', 'clientId', clientId)
            const localVarPath = `/api/sso/oauth/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['client_id'] = clientId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} redirectUri 
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoGoogleOAuthControllerGoogleAuthRedirect: async (redirectUri: string, clientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'redirectUri' is not null or undefined
            assertParamExists('ssoGoogleOAuthControllerGoogleAuthRedirect', 'redirectUri', redirectUri)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('ssoGoogleOAuthControllerGoogleAuthRedirect', 'clientId', clientId)
            const localVarPath = `/api/sso/oauth/google/redirect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['client_id'] = clientId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoOAuthControllerOauthProviders: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/oauth/providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SsoOAuthVerificationArgs} ssoOAuthVerificationArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoOAuthControllerOauthVerification: async (ssoOAuthVerificationArgs: SsoOAuthVerificationArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ssoOAuthVerificationArgs' is not null or undefined
            assertParamExists('ssoOAuthControllerOauthVerification', 'ssoOAuthVerificationArgs', ssoOAuthVerificationArgs)
            const localVarPath = `/api/sso/oauth/verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ssoOAuthVerificationArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoPublicTenantsControllerFindMany: async (curPage?: number, perPage?: number, searchText?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/public-tenants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoRefreshSessionsControllerFindMany: async (userId: string, curPage?: number, perPage?: number, searchText?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('ssoRefreshSessionsControllerFindMany', 'userId', userId)
            const localVarPath = `/api/sso/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoRefreshSessionsControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ssoRefreshSessionsControllerFindOne', 'id', id)
            const localVarPath = `/api/sso/sessions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateSsoRefreshSessionDto} updateSsoRefreshSessionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoRefreshSessionsControllerUpdateOne: async (id: string, updateSsoRefreshSessionDto: UpdateSsoRefreshSessionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ssoRefreshSessionsControllerUpdateOne', 'id', id)
            // verify required parameter 'updateSsoRefreshSessionDto' is not null or undefined
            assertParamExists('ssoRefreshSessionsControllerUpdateOne', 'updateSsoRefreshSessionDto', updateSsoRefreshSessionDto)
            const localVarPath = `/api/sso/sessions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSsoRefreshSessionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoRolesControllerFindMany: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateSsoTenantDto} createSsoTenantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoTenantsControllerCreateOne: async (createSsoTenantDto: CreateSsoTenantDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createSsoTenantDto' is not null or undefined
            assertParamExists('ssoTenantsControllerCreateOne', 'createSsoTenantDto', createSsoTenantDto)
            const localVarPath = `/api/sso/tenants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSsoTenantDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoTenantsControllerDeleteOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ssoTenantsControllerDeleteOne', 'id', id)
            const localVarPath = `/api/sso/tenants/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoTenantsControllerFindMany: async (curPage?: number, perPage?: number, searchText?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/tenants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoTenantsControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ssoTenantsControllerFindOne', 'id', id)
            const localVarPath = `/api/sso/tenants/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateSsoTenantDto} updateSsoTenantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoTenantsControllerUpdateOne: async (id: string, updateSsoTenantDto: UpdateSsoTenantDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ssoTenantsControllerUpdateOne', 'id', id)
            // verify required parameter 'updateSsoTenantDto' is not null or undefined
            assertParamExists('ssoTenantsControllerUpdateOne', 'updateSsoTenantDto', updateSsoTenantDto)
            const localVarPath = `/api/sso/tenants/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSsoTenantDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoUsersControllerFindMany: async (curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenantId'] = tenantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoUsersControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ssoUsersControllerFindOne', 'id', id)
            const localVarPath = `/api/sso/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SendInvitationLinksArgs} sendInvitationLinksArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoUsersControllerSendInvitationLinks: async (sendInvitationLinksArgs: SendInvitationLinksArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendInvitationLinksArgs' is not null or undefined
            assertParamExists('ssoUsersControllerSendInvitationLinks', 'sendInvitationLinksArgs', sendInvitationLinksArgs)
            const localVarPath = `/api/sso/users/send-invitation-links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendInvitationLinksArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateSsoUserDto} updateSsoUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoUsersControllerUpdateOne: async (id: string, updateSsoUserDto: UpdateSsoUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ssoUsersControllerUpdateOne', 'id', id)
            // verify required parameter 'updateSsoUserDto' is not null or undefined
            assertParamExists('ssoUsersControllerUpdateOne', 'updateSsoUserDto', updateSsoUserDto)
            const localVarPath = `/api/sso/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSsoUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SsoApi - functional programming interface
 * @export
 */
export const SsoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SsoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CompleteForgotPasswordArgs} completeForgotPasswordArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoControllerCompleteForgotPassword(completeForgotPasswordArgs: CompleteForgotPasswordArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokensResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoControllerCompleteForgotPassword(completeForgotPasswordArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoControllerCompleteForgotPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CompleteSignUpArgs} completeSignUpArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoControllerCompleteSignUp(completeSignUpArgs: CompleteSignUpArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokensResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoControllerCompleteSignUp(completeSignUpArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoControllerCompleteSignUp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ForgotPasswordArgs} forgotPasswordArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoControllerForgotPassword(forgotPasswordArgs: ForgotPasswordArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoControllerForgotPassword(forgotPasswordArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoControllerForgotPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoControllerProfile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SsoUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoControllerProfile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoControllerProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RefreshTokensResponse} refreshTokensResponse 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoControllerRefreshTokens(refreshTokensResponse: RefreshTokensResponse, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokensResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoControllerRefreshTokens(refreshTokensResponse, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoControllerRefreshTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SignInArgs} signInArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoControllerSignIn(signInArgs: SignInArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokensResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoControllerSignIn(signInArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoControllerSignIn']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SignOutArgs} signOutArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoControllerSignOut(signOutArgs: SignOutArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoControllerSignOut(signOutArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoControllerSignOut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SignUpArgs} signUpArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoControllerSignUp(signUpArgs: SignUpArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokensResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoControllerSignUp(signUpArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoControllerSignUp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateProfileArgs} updateProfileArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoControllerUpdateProfile(updateProfileArgs: UpdateProfileArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SsoUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoControllerUpdateProfile(updateProfileArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoControllerUpdateProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoEmailTemplatesControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManySsoEmailTemplateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoEmailTemplatesControllerFindMany(curPage, perPage, searchText, sort, tenantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoEmailTemplatesControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoEmailTemplatesControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SsoEmailTemplateDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoEmailTemplatesControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoEmailTemplatesControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateSsoEmailTemplateDto} updateSsoEmailTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoEmailTemplatesControllerUpdateOne(id: string, updateSsoEmailTemplateDto: UpdateSsoEmailTemplateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SsoEmailTemplateDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoEmailTemplatesControllerUpdateOne(id, updateSsoEmailTemplateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoEmailTemplatesControllerUpdateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} redirectUri 
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoGoogleOAuthControllerGoogleAuth(redirectUri: string, clientId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoGoogleOAuthControllerGoogleAuth(redirectUri, clientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoGoogleOAuthControllerGoogleAuth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} redirectUri 
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoGoogleOAuthControllerGoogleAuthRedirect(redirectUri: string, clientId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoGoogleOAuthControllerGoogleAuthRedirect(redirectUri, clientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoGoogleOAuthControllerGoogleAuthRedirect']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoOAuthControllerOauthProviders(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OAuthProvider>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoOAuthControllerOauthProviders(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoOAuthControllerOauthProviders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SsoOAuthVerificationArgs} ssoOAuthVerificationArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoOAuthControllerOauthVerification(ssoOAuthVerificationArgs: SsoOAuthVerificationArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokensResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoOAuthControllerOauthVerification(ssoOAuthVerificationArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoOAuthControllerOauthVerification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoPublicTenantsControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManySsoPublicTenantResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoPublicTenantsControllerFindMany(curPage, perPage, searchText, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoPublicTenantsControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoRefreshSessionsControllerFindMany(userId: string, curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManySsoRefreshSessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoRefreshSessionsControllerFindMany(userId, curPage, perPage, searchText, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoRefreshSessionsControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoRefreshSessionsControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SsoRefreshSessionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoRefreshSessionsControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoRefreshSessionsControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateSsoRefreshSessionDto} updateSsoRefreshSessionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoRefreshSessionsControllerUpdateOne(id: string, updateSsoRefreshSessionDto: UpdateSsoRefreshSessionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SsoRefreshSessionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoRefreshSessionsControllerUpdateOne(id, updateSsoRefreshSessionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoRefreshSessionsControllerUpdateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoRolesControllerFindMany(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManySsoRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoRolesControllerFindMany(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoRolesControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateSsoTenantDto} createSsoTenantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoTenantsControllerCreateOne(createSsoTenantDto: CreateSsoTenantDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SsoTenantDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoTenantsControllerCreateOne(createSsoTenantDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoTenantsControllerCreateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoTenantsControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoTenantsControllerDeleteOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoTenantsControllerDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoTenantsControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManySsoTenantResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoTenantsControllerFindMany(curPage, perPage, searchText, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoTenantsControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoTenantsControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SsoTenantDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoTenantsControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoTenantsControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateSsoTenantDto} updateSsoTenantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoTenantsControllerUpdateOne(id: string, updateSsoTenantDto: UpdateSsoTenantDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SsoTenantDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoTenantsControllerUpdateOne(id, updateSsoTenantDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoTenantsControllerUpdateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoUsersControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManySsoUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoUsersControllerFindMany(curPage, perPage, searchText, sort, tenantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoUsersControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoUsersControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SsoUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoUsersControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoUsersControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SendInvitationLinksArgs} sendInvitationLinksArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoUsersControllerSendInvitationLinks(sendInvitationLinksArgs: SendInvitationLinksArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoUsersControllerSendInvitationLinks(sendInvitationLinksArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoUsersControllerSendInvitationLinks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateSsoUserDto} updateSsoUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoUsersControllerUpdateOne(id: string, updateSsoUserDto: UpdateSsoUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SsoUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoUsersControllerUpdateOne(id, updateSsoUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoApi.ssoUsersControllerUpdateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SsoApi - factory interface
 * @export
 */
export const SsoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SsoApiFp(configuration)
    return {
        /**
         * 
         * @param {CompleteForgotPasswordArgs} completeForgotPasswordArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoControllerCompleteForgotPassword(completeForgotPasswordArgs: CompleteForgotPasswordArgs, options?: RawAxiosRequestConfig): AxiosPromise<TokensResponse> {
            return localVarFp.ssoControllerCompleteForgotPassword(completeForgotPasswordArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CompleteSignUpArgs} completeSignUpArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoControllerCompleteSignUp(completeSignUpArgs: CompleteSignUpArgs, options?: RawAxiosRequestConfig): AxiosPromise<TokensResponse> {
            return localVarFp.ssoControllerCompleteSignUp(completeSignUpArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ForgotPasswordArgs} forgotPasswordArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoControllerForgotPassword(forgotPasswordArgs: ForgotPasswordArgs, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.ssoControllerForgotPassword(forgotPasswordArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoControllerProfile(options?: RawAxiosRequestConfig): AxiosPromise<SsoUserDto> {
            return localVarFp.ssoControllerProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RefreshTokensResponse} refreshTokensResponse 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoControllerRefreshTokens(refreshTokensResponse: RefreshTokensResponse, options?: RawAxiosRequestConfig): AxiosPromise<TokensResponse> {
            return localVarFp.ssoControllerRefreshTokens(refreshTokensResponse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SignInArgs} signInArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoControllerSignIn(signInArgs: SignInArgs, options?: RawAxiosRequestConfig): AxiosPromise<TokensResponse> {
            return localVarFp.ssoControllerSignIn(signInArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SignOutArgs} signOutArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoControllerSignOut(signOutArgs: SignOutArgs, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.ssoControllerSignOut(signOutArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SignUpArgs} signUpArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoControllerSignUp(signUpArgs: SignUpArgs, options?: RawAxiosRequestConfig): AxiosPromise<TokensResponse> {
            return localVarFp.ssoControllerSignUp(signUpArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateProfileArgs} updateProfileArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoControllerUpdateProfile(updateProfileArgs: UpdateProfileArgs, options?: RawAxiosRequestConfig): AxiosPromise<SsoUserDto> {
            return localVarFp.ssoControllerUpdateProfile(updateProfileArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoEmailTemplatesControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManySsoEmailTemplateResponse> {
            return localVarFp.ssoEmailTemplatesControllerFindMany(curPage, perPage, searchText, sort, tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoEmailTemplatesControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<SsoEmailTemplateDto> {
            return localVarFp.ssoEmailTemplatesControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateSsoEmailTemplateDto} updateSsoEmailTemplateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoEmailTemplatesControllerUpdateOne(id: string, updateSsoEmailTemplateDto: UpdateSsoEmailTemplateDto, options?: RawAxiosRequestConfig): AxiosPromise<SsoEmailTemplateDto> {
            return localVarFp.ssoEmailTemplatesControllerUpdateOne(id, updateSsoEmailTemplateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} redirectUri 
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoGoogleOAuthControllerGoogleAuth(redirectUri: string, clientId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.ssoGoogleOAuthControllerGoogleAuth(redirectUri, clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} redirectUri 
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoGoogleOAuthControllerGoogleAuthRedirect(redirectUri: string, clientId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.ssoGoogleOAuthControllerGoogleAuthRedirect(redirectUri, clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoOAuthControllerOauthProviders(options?: RawAxiosRequestConfig): AxiosPromise<Array<OAuthProvider>> {
            return localVarFp.ssoOAuthControllerOauthProviders(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SsoOAuthVerificationArgs} ssoOAuthVerificationArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoOAuthControllerOauthVerification(ssoOAuthVerificationArgs: SsoOAuthVerificationArgs, options?: RawAxiosRequestConfig): AxiosPromise<TokensResponse> {
            return localVarFp.ssoOAuthControllerOauthVerification(ssoOAuthVerificationArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoPublicTenantsControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManySsoPublicTenantResponse> {
            return localVarFp.ssoPublicTenantsControllerFindMany(curPage, perPage, searchText, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoRefreshSessionsControllerFindMany(userId: string, curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManySsoRefreshSessionResponse> {
            return localVarFp.ssoRefreshSessionsControllerFindMany(userId, curPage, perPage, searchText, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoRefreshSessionsControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<SsoRefreshSessionDto> {
            return localVarFp.ssoRefreshSessionsControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateSsoRefreshSessionDto} updateSsoRefreshSessionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoRefreshSessionsControllerUpdateOne(id: string, updateSsoRefreshSessionDto: UpdateSsoRefreshSessionDto, options?: RawAxiosRequestConfig): AxiosPromise<SsoRefreshSessionDto> {
            return localVarFp.ssoRefreshSessionsControllerUpdateOne(id, updateSsoRefreshSessionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoRolesControllerFindMany(options?: RawAxiosRequestConfig): AxiosPromise<FindManySsoRoleResponse> {
            return localVarFp.ssoRolesControllerFindMany(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateSsoTenantDto} createSsoTenantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoTenantsControllerCreateOne(createSsoTenantDto: CreateSsoTenantDto, options?: RawAxiosRequestConfig): AxiosPromise<SsoTenantDto> {
            return localVarFp.ssoTenantsControllerCreateOne(createSsoTenantDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoTenantsControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.ssoTenantsControllerDeleteOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoTenantsControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManySsoTenantResponse> {
            return localVarFp.ssoTenantsControllerFindMany(curPage, perPage, searchText, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoTenantsControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<SsoTenantDto> {
            return localVarFp.ssoTenantsControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateSsoTenantDto} updateSsoTenantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoTenantsControllerUpdateOne(id: string, updateSsoTenantDto: UpdateSsoTenantDto, options?: RawAxiosRequestConfig): AxiosPromise<SsoTenantDto> {
            return localVarFp.ssoTenantsControllerUpdateOne(id, updateSsoTenantDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoUsersControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManySsoUserResponse> {
            return localVarFp.ssoUsersControllerFindMany(curPage, perPage, searchText, sort, tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoUsersControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<SsoUserDto> {
            return localVarFp.ssoUsersControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SendInvitationLinksArgs} sendInvitationLinksArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoUsersControllerSendInvitationLinks(sendInvitationLinksArgs: SendInvitationLinksArgs, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.ssoUsersControllerSendInvitationLinks(sendInvitationLinksArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateSsoUserDto} updateSsoUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoUsersControllerUpdateOne(id: string, updateSsoUserDto: UpdateSsoUserDto, options?: RawAxiosRequestConfig): AxiosPromise<SsoUserDto> {
            return localVarFp.ssoUsersControllerUpdateOne(id, updateSsoUserDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SsoApi - object-oriented interface
 * @export
 * @class SsoApi
 * @extends {BaseAPI}
 */
export class SsoApi extends BaseAPI {
    /**
     * 
     * @param {CompleteForgotPasswordArgs} completeForgotPasswordArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoControllerCompleteForgotPassword(completeForgotPasswordArgs: CompleteForgotPasswordArgs, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoControllerCompleteForgotPassword(completeForgotPasswordArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CompleteSignUpArgs} completeSignUpArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoControllerCompleteSignUp(completeSignUpArgs: CompleteSignUpArgs, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoControllerCompleteSignUp(completeSignUpArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ForgotPasswordArgs} forgotPasswordArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoControllerForgotPassword(forgotPasswordArgs: ForgotPasswordArgs, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoControllerForgotPassword(forgotPasswordArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoControllerProfile(options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoControllerProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RefreshTokensResponse} refreshTokensResponse 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoControllerRefreshTokens(refreshTokensResponse: RefreshTokensResponse, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoControllerRefreshTokens(refreshTokensResponse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SignInArgs} signInArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoControllerSignIn(signInArgs: SignInArgs, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoControllerSignIn(signInArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SignOutArgs} signOutArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoControllerSignOut(signOutArgs: SignOutArgs, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoControllerSignOut(signOutArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SignUpArgs} signUpArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoControllerSignUp(signUpArgs: SignUpArgs, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoControllerSignUp(signUpArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateProfileArgs} updateProfileArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoControllerUpdateProfile(updateProfileArgs: UpdateProfileArgs, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoControllerUpdateProfile(updateProfileArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {string} [tenantId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoEmailTemplatesControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoEmailTemplatesControllerFindMany(curPage, perPage, searchText, sort, tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoEmailTemplatesControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoEmailTemplatesControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateSsoEmailTemplateDto} updateSsoEmailTemplateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoEmailTemplatesControllerUpdateOne(id: string, updateSsoEmailTemplateDto: UpdateSsoEmailTemplateDto, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoEmailTemplatesControllerUpdateOne(id, updateSsoEmailTemplateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} redirectUri 
     * @param {string} clientId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoGoogleOAuthControllerGoogleAuth(redirectUri: string, clientId: string, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoGoogleOAuthControllerGoogleAuth(redirectUri, clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} redirectUri 
     * @param {string} clientId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoGoogleOAuthControllerGoogleAuthRedirect(redirectUri: string, clientId: string, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoGoogleOAuthControllerGoogleAuthRedirect(redirectUri, clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoOAuthControllerOauthProviders(options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoOAuthControllerOauthProviders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SsoOAuthVerificationArgs} ssoOAuthVerificationArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoOAuthControllerOauthVerification(ssoOAuthVerificationArgs: SsoOAuthVerificationArgs, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoOAuthControllerOauthVerification(ssoOAuthVerificationArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoPublicTenantsControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoPublicTenantsControllerFindMany(curPage, perPage, searchText, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoRefreshSessionsControllerFindMany(userId: string, curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoRefreshSessionsControllerFindMany(userId, curPage, perPage, searchText, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoRefreshSessionsControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoRefreshSessionsControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateSsoRefreshSessionDto} updateSsoRefreshSessionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoRefreshSessionsControllerUpdateOne(id: string, updateSsoRefreshSessionDto: UpdateSsoRefreshSessionDto, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoRefreshSessionsControllerUpdateOne(id, updateSsoRefreshSessionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoRolesControllerFindMany(options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoRolesControllerFindMany(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateSsoTenantDto} createSsoTenantDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoTenantsControllerCreateOne(createSsoTenantDto: CreateSsoTenantDto, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoTenantsControllerCreateOne(createSsoTenantDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoTenantsControllerDeleteOne(id: string, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoTenantsControllerDeleteOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoTenantsControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoTenantsControllerFindMany(curPage, perPage, searchText, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoTenantsControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoTenantsControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateSsoTenantDto} updateSsoTenantDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoTenantsControllerUpdateOne(id: string, updateSsoTenantDto: UpdateSsoTenantDto, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoTenantsControllerUpdateOne(id, updateSsoTenantDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {string} [tenantId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoUsersControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoUsersControllerFindMany(curPage, perPage, searchText, sort, tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoUsersControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoUsersControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SendInvitationLinksArgs} sendInvitationLinksArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoUsersControllerSendInvitationLinks(sendInvitationLinksArgs: SendInvitationLinksArgs, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoUsersControllerSendInvitationLinks(sendInvitationLinksArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateSsoUserDto} updateSsoUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoUsersControllerUpdateOne(id: string, updateSsoUserDto: UpdateSsoUserDto, options?: RawAxiosRequestConfig) {
        return SsoApiFp(this.configuration).ssoUsersControllerUpdateOne(id, updateSsoUserDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TerminusHealthCheckApi - axios parameter creator
 * @export
 */
export const TerminusHealthCheckApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminusHealthCheckControllerCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TerminusHealthCheckApi - functional programming interface
 * @export
 */
export const TerminusHealthCheckApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TerminusHealthCheckApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async terminusHealthCheckControllerCheck(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TerminusHealthCheckControllerCheck200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.terminusHealthCheckControllerCheck(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TerminusHealthCheckApi.terminusHealthCheckControllerCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TerminusHealthCheckApi - factory interface
 * @export
 */
export const TerminusHealthCheckApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TerminusHealthCheckApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminusHealthCheckControllerCheck(options?: RawAxiosRequestConfig): AxiosPromise<TerminusHealthCheckControllerCheck200Response> {
            return localVarFp.terminusHealthCheckControllerCheck(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TerminusHealthCheckApi - object-oriented interface
 * @export
 * @class TerminusHealthCheckApi
 * @extends {BaseAPI}
 */
export class TerminusHealthCheckApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerminusHealthCheckApi
     */
    public terminusHealthCheckControllerCheck(options?: RawAxiosRequestConfig) {
        return TerminusHealthCheckApiFp(this.configuration).terminusHealthCheckControllerCheck(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TimeApi - axios parameter creator
 * @export
 */
export const TimeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeControllerTime: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/time`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimeApi - functional programming interface
 * @export
 */
export const TimeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TimeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timeControllerTime(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timeControllerTime(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimeApi.timeControllerTime']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TimeApi - factory interface
 * @export
 */
export const TimeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TimeApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeControllerTime(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.timeControllerTime(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TimeApi - object-oriented interface
 * @export
 * @class TimeApi
 * @extends {BaseAPI}
 */
export class TimeApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeApi
     */
    public timeControllerTime(options?: RawAxiosRequestConfig) {
        return TimeApiFp(this.configuration).timeControllerTime(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebhookApi - axios parameter creator
 * @export
 */
export const WebhookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateWebhookDto} createWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerCreateOne: async (createWebhookDto: CreateWebhookDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWebhookDto' is not null or undefined
            assertParamExists('webhookControllerCreateOne', 'createWebhookDto', createWebhookDto)
            const localVarPath = `/api/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWebhookDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerDeleteOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('webhookControllerDeleteOne', 'id', id)
            const localVarPath = `/api/webhook/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerEvents: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/webhook/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerFindMany: async (curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenantId'] = tenantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('webhookControllerFindOne', 'id', id)
            const localVarPath = `/api/webhook/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerProfile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/webhook/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateWebhookDto} createWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerTestRequest: async (createWebhookDto: CreateWebhookDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWebhookDto' is not null or undefined
            assertParamExists('webhookControllerTestRequest', 'createWebhookDto', createWebhookDto)
            const localVarPath = `/api/webhook/test-request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWebhookDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateWebhookDto} updateWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerUpdateOne: async (id: string, updateWebhookDto: UpdateWebhookDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('webhookControllerUpdateOne', 'id', id)
            // verify required parameter 'updateWebhookDto' is not null or undefined
            assertParamExists('webhookControllerUpdateOne', 'updateWebhookDto', updateWebhookDto)
            const localVarPath = `/api/webhook/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWebhookDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookLogsControllerDeleteOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('webhookLogsControllerDeleteOne', 'id', id)
            const localVarPath = `/api/webhook/logs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookLogsControllerFindManyLogs: async (webhookId: string, curPage?: number, perPage?: number, searchText?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('webhookLogsControllerFindManyLogs', 'webhookId', webhookId)
            const localVarPath = `/api/webhook/logs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (webhookId !== undefined) {
                localVarQueryParameter['webhookId'] = webhookId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookLogsControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('webhookLogsControllerFindOne', 'id', id)
            const localVarPath = `/api/webhook/logs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhookApi - functional programming interface
 * @export
 */
export const WebhookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhookApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateWebhookDto} createWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerCreateOne(createWebhookDto: CreateWebhookDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerCreateOne(createWebhookDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerCreateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerDeleteOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerEvents(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebhookEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerEvents(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManyWebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerFindMany(curPage, perPage, searchText, sort, tenantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerProfile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerProfile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateWebhookDto} createWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerTestRequest(createWebhookDto: CreateWebhookDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookTestRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerTestRequest(createWebhookDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerTestRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateWebhookDto} updateWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerUpdateOne(id: string, updateWebhookDto: UpdateWebhookDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerUpdateOne(id, updateWebhookDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerUpdateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookLogsControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookLogsControllerDeleteOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookLogsControllerDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookLogsControllerFindManyLogs(webhookId: string, curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManyWebhookLogResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookLogsControllerFindManyLogs(webhookId, curPage, perPage, searchText, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookLogsControllerFindManyLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookLogsControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookLogsControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookLogsControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhookApi - factory interface
 * @export
 */
export const WebhookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhookApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateWebhookDto} createWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerCreateOne(createWebhookDto: CreateWebhookDto, options?: RawAxiosRequestConfig): AxiosPromise<Webhook> {
            return localVarFp.webhookControllerCreateOne(createWebhookDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.webhookControllerDeleteOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerEvents(options?: RawAxiosRequestConfig): AxiosPromise<Array<WebhookEvent>> {
            return localVarFp.webhookControllerEvents(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManyWebhookResponse> {
            return localVarFp.webhookControllerFindMany(curPage, perPage, searchText, sort, tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Webhook> {
            return localVarFp.webhookControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerProfile(options?: RawAxiosRequestConfig): AxiosPromise<WebhookUser> {
            return localVarFp.webhookControllerProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateWebhookDto} createWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerTestRequest(createWebhookDto: CreateWebhookDto, options?: RawAxiosRequestConfig): AxiosPromise<WebhookTestRequestResponse> {
            return localVarFp.webhookControllerTestRequest(createWebhookDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateWebhookDto} updateWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerUpdateOne(id: string, updateWebhookDto: UpdateWebhookDto, options?: RawAxiosRequestConfig): AxiosPromise<Webhook> {
            return localVarFp.webhookControllerUpdateOne(id, updateWebhookDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookLogsControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.webhookLogsControllerDeleteOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookLogsControllerFindManyLogs(webhookId: string, curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManyWebhookLogResponse> {
            return localVarFp.webhookLogsControllerFindManyLogs(webhookId, curPage, perPage, searchText, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookLogsControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<WebhookLog> {
            return localVarFp.webhookLogsControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhookApi - object-oriented interface
 * @export
 * @class WebhookApi
 * @extends {BaseAPI}
 */
export class WebhookApi extends BaseAPI {
    /**
     * 
     * @param {CreateWebhookDto} createWebhookDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerCreateOne(createWebhookDto: CreateWebhookDto, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerCreateOne(createWebhookDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerDeleteOne(id: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerDeleteOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerEvents(options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerEvents(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {string} [tenantId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerFindMany(curPage, perPage, searchText, sort, tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerProfile(options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateWebhookDto} createWebhookDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerTestRequest(createWebhookDto: CreateWebhookDto, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerTestRequest(createWebhookDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateWebhookDto} updateWebhookDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerUpdateOne(id: string, updateWebhookDto: UpdateWebhookDto, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerUpdateOne(id, updateWebhookDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookLogsControllerDeleteOne(id: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookLogsControllerDeleteOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} webhookId 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookLogsControllerFindManyLogs(webhookId: string, curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookLogsControllerFindManyLogs(webhookId, curPage, perPage, searchText, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookLogsControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookLogsControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }
}



